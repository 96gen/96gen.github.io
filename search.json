[{"title":"用Hexo打造靜態Blog","url":"/2024/10/09/build-hexo-github-page/","content":"這個網站採用Hexo框架，接下來簡述我是如何完成的。\nHexo\nbun install hexo-cli -g #安裝Hexo\nhexo init blog #建立Hexo專案\ncd blog\nbun install #安裝使用的套件\n\nHexo theme我不喜歡預設的theme，前往https://hexo.io/themes/查看其它theme。最終選擇hexo-theme-arknights\n\ngit clone https://github.com/Yue-plus/hexo-theme-arknights.git themes&#x2F;arknights #下載theme\nbun install hexo-server hexo-browsersync hexo-renderer-pug hexo-wordcount –save\n將themes&#x2F;arknights&#x2F;_config.yml改名成_config.arknights.yml\n修改_config.arknights.yml，呈現變化的部分，其餘維持原樣aside:  logo: /img/faction/6.png #自己新增的透明圖片  copyright:     copyright:       CC BY-NC-SA 4.0: https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zhpost:  count: true   time: true \n修改_config.yml，啟用arknights themetheme: arknights\nhexo server #啟動\n\n我們的靜態Blog就完成了\n部署到Github Page\nbun install hexo-deployer-git –save\n修改_config.ymlurl: http://96gen.github.iodeploy:  type: git  repo: https://github.com/96gen/96gen.github.io.git  branch: master\n在Github建立Repository，名稱為96gen.github.io\n進入Repository設定，側邊欄尋找Pages，Source選擇Deploy from a branch，Branch選擇master後儲存\n回到Hexo專案，hexo deploy，上傳到Github\n\n編寫貼文\nhexo new post post_name #建立新的post\n前往source&#x2F;_posts，尋找post_name.md，使用markdown格式開始寫作有多個tag時，需要像這樣tags: [Hexo, Blog, Github Page]\n\n","categories":["Web"],"tags":["Hexo","Blog","Github Page"]},{"title":"五個沒用但是有趣的Linux的指令","url":"/2024/11/12/interesting-linux-command/","content":"今天要介紹幾個 Linux 指令，雖然它們沒有實際用途，但卻充滿趣味！\n\n提醒：以下指令都需要安裝相應的套件，套件名稱和小標題相同。\n\n\nasciiquarium輸入 asciiquarium，畫面上會出現由文字組成的魚群在「水中」悠游，營造出有趣的水族箱效果。按 q 即可結束。\ncmatrix想要偽裝成駭客嗎？cmatrix 也許能滿足你的願望。輸入 cmatrix，綠色字元就會像駭客風格的螢幕那樣不斷滾動，按 q 結束。\n你也可以切換顏色，例如輸入 cmatrix -C red 切換到紅色，或用 cmatrix -r 讓字元色彩繽紛。\nhollywood覺得 cmatrix 不夠駭客？那麼 hollywood 這個指令更能滿足你的駭客情境需求。輸入 hollywood，螢幕將模擬出各種看似高科技的終端畫面，似乎正在破解防火牆。按下 Ctrl + C 即可結束。\ncowsay撰寫教學文件時想加點趣味？可以試試 cowsay 讓小牛說話！例如，輸入 cowsay &quot;Hello, World!&quot;，會出現以下內容：\n _______________&lt; Hello, World! &gt; ---------------        \\   ^__^         \\  (oo)\\_______            (__)\\       )\\/\\                ||----w |                ||     ||\n\n除了牛，cowsay 還提供其他角色，使用 cowsay -l 查看完整角色列表。\n切換角色時，輸入 cowsay -f 角色名，如要用兔子角色，可以輸入 cowsay -f bunny &quot;Hello, World!&quot;：\n _______________&lt; Hello, World! &gt; ---------------  \\   \\   \\        \\ /\\        ( )      .( o ).\n\nbastetbastet 可以讓你在終端機中玩俄羅斯方塊！輸入 bastet 開始遊戲，按 Ctrl + C 結束。\n\n這些指令可能在工作上幫不上忙，但偶爾用來放鬆心情還是很不錯的。試試看吧！\n","tags":["Linux"]},{"title":"如何排除 Linux 硬碟讀寫緩慢的問題","url":"/2024/11/18/linux-debug-01/","content":"\n檢查硬碟是否忙碌\n\n使用 top 指令查看硬碟的運作狀況，特別注意 wa 的數值。wa 代表 CPU 等待 I&#x2F;O 的時間百分比，如果該數值接近 1，表示硬碟正在進行大量讀寫。\n\n定位占用硬碟資源的行程\n\n使用 iotop 工具，可以按順序列出行程的硬碟使用情況。記錄頻繁使用硬碟的行程的 TID。\n\n查找對應的 PID\n\n輸入 ps -eLf | grep TID號碼，從中找到對應行程的 PID。\n\n檢查行程的讀寫檔案\n\n使用 lsof -p PID編號，查看該行程正在讀寫的檔案，並檢查是否存在異常的讀寫行為。\n\n檢測硬碟壞軌\n\n如果上述方法無法解決問題，可能是硬碟存在壞軌。可使用 badblocks 工具來檢測硬碟是否有壞軌。\n","tags":["Linux"]},{"title":"如何解決 Linux RAM 使用率高的問題？","url":"/2024/11/25/linux-debug-02/","content":"當 Linux 系統的 RAM 使用率過高時，可能會導致效能下降，甚至影響服務的穩定性。\n以下是檢測與解決問題的步驟：  \n1. 檢視 RAM 使用狀況可以使用以下指令查看系統 RAM 的使用情形：  \nfree -m\n\n\nused 值高、free 值低 表示 RAM 使用率偏高。\n\n2. 找出高 RAM 使用率的行程使用以下指令檢查具體行程的 RAM 使用狀況： \ntop\n\n\n查看 MEM% 欄位，該值越高表示行程佔用的 RAM 越多。\n\n3. 解決方法\n針對非必要行程  \n\n確認是否有不常使用的行程持續佔用 RAM，例如不必要的服務或可能有記憶體洩漏的程式。  \n若懷疑行程有問題，檢查原始碼或更新至修正版以修復記憶體使用異常。\n\n\n針對核心業務  \n\n若 RAM 高使用率來自網站伺服器、資料庫等常用服務，這可能意味著伺服器資源不足。  \n考慮以下解決方案：  \n優化程式：檢查程式是否有機會改善資源分配，降低記憶體消耗。  \n增加 RAM：升級伺服器硬體配置，確保 RAM 足以應付系統需求。\n\n\n\n\n\n透過上述步驟，可以有效診斷並解決 RAM 使用率高的問題，確保系統穩定運行。\n","tags":["Linux"]},{"title":"如何使用PuTTY私鑰登入","url":"/2024/11/11/putty-ssh-tutorial/","content":"將公鑰傳輸到Server公鑰可以直接在網路上傳輸，因此可以用多種方式：雲端硬碟、FTP或複製貼上。\n在此示範如何透過SSH複製貼上，先使用密碼連接Server，輸入\nsudo nano ~/.ssh/authorized_keys #編輯並新增authorized_keyssudo chmod 755 ~/.ssh/authorized_keys #修改檔案權限，全部人可讀和執行，擁有者可以可讀、寫和執行\n\n會進入另一個畫面\n\n複製前面產生的公鑰\n確認成功複製後，在PuTTY的視窗按右鍵，可以貼上複製的內容\n按Ctrl+O保存修改，Ctrl+X離開\n\n設定PuTTY使用私鑰我們開啟PuTTY\n\n在左邊尋找Connection→SSH→Auth→Credential，有一部分被隱藏了，可以按下+展開。\n按下Private key file for authentication下的Browse，選擇私鑰。\n回到Session，點擊右邊的Default Settings，按下右側的Save，儲存我們的設定，下次連線時就不用重新設定私鑰。\n按下Open連線，輸入用戶名。\n\n我們不需要輸入密碼，就能進入Ubuntu，代表公鑰和私鑰的設定成功。\n"},{"title":"使用PuTTYgen產生金鑰","url":"/2024/11/10/puttygen-generate-key/","content":"在連接 VPS 時，我們可以選擇使用密碼或私鑰。有些 VPS 不允許直接使用密碼登入，必須使用私鑰。這篇教學的目的是在教大家如何產生用於 VPS 的私鑰。\n使用 PuTTYgen 產生金鑰我們使用 PuTTYgen 來產生金鑰。\n\n選擇金鑰類型\n\n在最下面的 Parameter 區塊，有 RSA、DSA、ECDSA、EdDSA、SSH-1(RSA) 五種選項。我們選擇 EdDSA，維持預設的 Ed25519 (255 bits)。這個標準產生的金鑰更小，並且提供了更強的安全性。\n\n產生金鑰\n\n在中間的 Action 區塊，按下 Generate 開始產生金鑰。過程中需要持續移動滑鼠以提供隨機數據。結束後，可以看到公鑰出現在 Key 區域。\n\n複製公鑰\n\n將畫面上 Public key for … 下面的內容複製，看起來是這樣的：\nbashssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOJDrmgSd310s+TuK5Tr8IlKHEpC2Vh/bCVkn6nOt5M2 eddsa-key-xxxxxxxxx\n\n這是我們的公鑰，不要使用 Save public key，因為它不符合 OpenSSH Server 的格式。\n\n保存私鑰\n\n按下 Action 區塊的 Save private key，系統會提醒我們沒有用密碼保護私鑰。由於我們的伺服器沒有高度機密的內容，所以可以不加密。按 Yes 確認不使用密碼，然後選擇位置並命名為 ssh_private_key.ppk。\n現在，我們取得了公鑰和私鑰，可以關閉 PuTTYgen 了。\n"},{"title":"Spring Boot project-oriented programming（1）前言","url":"/2024/10/10/spring-boot-pop-01/","content":"前言市面上已有許多關於 Spring Boot 的教學，大多以控制反轉（Inversion of Control，簡稱 IoC）和 Bean 為起點，逐步引導讀者了解 Spring Boot 的架構設計。這些教學對於想要紮實掌握基礎的學習者非常有幫助。然而，從實作一個專案的角度來學習，能夠更有效地應用這些知識。\n本篇教學適合以下幾類讀者：\n\n已經具備 Spring Boot 基礎知識，或認為不需要深入基礎講解的學習者。\n\n有 Java 程式經驗，因為我們將用 Java 完成 Spring Boot 專案。\n\n想要獨立完成 Spring Boot 專案的人。\n\n\n接下來的教學不會詳述 IoC、Bean 或 AOP 的基本概念，而是直接著手於專案開發。\n個人經驗分享在我初次接觸 Spring Boot 時，首先學習的是 IoC 的理論和實作方式，並隨之接觸到 Bean 和導向程式設計（Aspect-Oriented Programming, AOP）。這些概念幫助我完成了第一個 “Hello World” 專案。然而，在後續的專案中，我發現自己很少直接使用這些基礎概念，因為 Spring 框架已經自動化處理了很多事情。這讓我開始思考，若當初能參與一個以實際專案為導向的課程，學習曲線或許會更順暢。\n教學內容為了幫助讀者高效學習，本教學將聚焦於如何完成具體的專案，而非深入討論 IoC、Bean 或 AOP 的原理。課程內容將帶領大家逐步實作專案，透過實戰操作來學習如何搭建 Spring Boot 應用程式。\n我們會提供完整的專案範例並解釋每個步驟的用意，讓讀者在實作過程中不僅理解專案運作，也能迅速掌握 Spring Boot 的開發流程。\n預計完成的專案以下是我們將完成的專案名稱及將學習的技巧：\n\nHello World 專案\n\n\n建立 Spring Boot 專案\n\n使用 Controller 在網頁上顯示內容\n\n\n\n待辦事項清單\n\n\n連接 Spring Boot 專案至資料庫\n\n完成 RESTful API\n\n使用測試工具測試 API\n\n打包專案成 jar 檔\n\n\n\n書籍管理系統\n\n\n在 MariaDB 中建立資料庫\n\n使用 YAML 配置專案設定\n\n\n\n客戶管理系統\n\n\n在 Spring Boot 中整合 MongoDB\n\n使用 Thymeleaf 建立簡易前端介面\n\n\n\n會員註冊與登入系統\n\n\n使用 Spring Security 完成權限管理\n\n\n購物車系統\n\n\n整合 Json Web Token（JWT）與 Spring Security 進行權限驗證\n\n\nAI 專案\n\n\n在 Spring Boot 專案中整合 Ollama，用於 AI 聊天及影像辨識\n\n此外，為了幫助學習前後端整合，我們還將開發兩個前端專案：\n\nReact Restful API 前端\n\n\n使用 Bun、Tailwind CSS、Axios 及 React-router-dom 完成 React 前端專案\n\n\nVue.js 購物車前端\n\n\n使用 Vue Router、Pinia、並打包 Vue 專案\n部署至 Linux 伺服器\n\n結語透過本教學，讀者將能夠從零開始實作完整的 Spring Boot 專案，掌握從後端 API 到前端整合的全端開發技能。希望這些實作經驗能幫助大家快速提升開發能力，並應用於實際工作中。\n","categories":["Java"],"tags":["Java","Spring Boot"]},{"title":"Spring Boot project-oriented programming（2）Hello World","url":"/2024/10/11/spring-boot-pop-02/","content":"專案挑戰的第一步是「Hello World」，這是一個建立Spring Boot專案並回應「Hello World」的入門專案。看似簡單，卻能讓初學者逐步熟悉專案環境設置與開發流程。\n步驟一：安裝與設置 IDE首先，我們會使用 IntelliJ IDEA Community ，這是一個免費的 IDE 工具來進行專案開發。在下載和安裝的過程中，請選擇「Community」版，而非「Ultimate」版，後者僅提供30天試用。\n下載並安裝完成後，打開 IntelliJ，準備開始新專案。\n步驟二：使用 Spring Initializr 建立專案接著，我們會使用 Spring Initializr ，這是一個官方提供的快速設定工具。Spring Initializr 能幫助你輕鬆生成一個基本的 Spring Boot 專案結構，以下是設定過程：\n\n選擇 Spring Boot 版本：可使用最新的穩定版，預設通常是最佳選擇。\n填寫專案資訊：設定 Group、Artifact 及 Description，可以自訂專案名稱或「Hello World」。\n選擇 Dependency：只需選擇 Spring Web，因為這是 Web 應用程式的基礎。\n\n\n點擊 GENERATE 後下載並解壓縮的專案。\n步驟三：打開專案並設置 Controller在 IntelliJ 中打開剛解壓縮的專案，等到右下角的進度條消失，表示專案已經完全載入完成。接下來，在 src/main/java 資料夾下創建一個新 Package，命名為 com.helloworld.controller，並在該 Package 內創建一個名為 HelloWorldController.java 的 Java Class。\nHelloWorldController.java 範例package com.helloworld.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorldController &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot;Hello, World!&quot;;    &#125;&#125;\n\n此 Controller 會接收來自 /hello 的請求，並回應「Hello, World!」。\n步驟四：執行專案並驗證結果返回 HelloWorldApplication.java，點擊 public static void main 函數旁邊的綠色三角形啟動專案。首次啟動時，可能需要設置 JDK，選擇版本 17 並安裝 Amazon Corretto。\n執行後，打開瀏覽器並進入 http://localhost:8080/hello，你將看到「Hello, World!」的訊息。\n\n進階操作：修改 Port如果想修改應用的預設 Port，可以在 src/main/resources/application.properties 中添加以下代碼：\nserver.port=8081\n\n此時，請求網址將改為 http://localhost:8081/hello。\n多種 Controller 寫法除了上述的簡單寫法，還有其他幾種變化，讓我們簡單了解一下不同的寫法：\n\n使用 @Controller 和 @ResponseBody：\n\n@ResponseBody@Controllerpublic class HelloWorldController &#123;    @RequestMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot;Hello, World!&quot;;    &#125;&#125;\n\n\n組合 @RequestMapping：\n\n@RestController@RequestMapping(&quot;/hello&quot;)public class HelloWorldController &#123;    @RequestMapping(&quot;&quot;)    public String hello()&#123;        return &quot;Hello, World!&quot;;    &#125;    @RequestMapping(&quot;/spring&quot;)    public String helloSpring()&#123;        return &quot;Hello, Spring!&quot;;    &#125;&#125;\n\n這樣的寫法有助於簡化 URL 的處理，避免重複的 /hello 路徑。\n結論透過這個專案，初學者可以熟悉 Spring Boot 的基本架構和控制器的創建過程。\nhttps://mega.nz/file/oU0TEA5a#bQntVal2ohH5S3J4FDDkVBxpeq2K8qa8NO-Ld6HALU8\n","categories":["Java"],"tags":["Java","Spring Boot"]},{"title":"Spring Boot project-oriented programming（4）API專案 連接資料庫","url":"/2024/10/13/spring-boot-pop-04/","content":"專案實作說明我們已經完成了專案的設計階段，現在將正式開始實作。\n\n1. 建立專案前往 Spring Initializr 產生一個新專案，以下是設定範例：  \n\nProject: Maven\nLanguage: Java  \nSpring Boot: 3.x 最新版  \nDependencies:  \nSpring Data JPA  \nH2 Database  \nSpring Boot DevTools\n\n\n\n依照需求調整後，點擊 Generate 下載專案。  \n\n\n使用到的 Dependencies 簡介1. Spring Data JPA提供 ORM 功能，讓 Java 程式碼和資料庫表結構能夠自動對應。使用 Spring Data JPA，我們可以不必手動撰寫 SQL 指令，即可完成資料庫操作，如 CRUD（新增、查詢、更新、刪除）。\n2. H2 DatabaseH2 是一個輕量級資料庫，方便測試用途，資料存在記憶體中，系統重啟後資料會消失，適合作為開發階段的臨時資料庫。\n3. Spring Boot DevTools支援程式自動重載，在我們修改程式碼後，專案會立即重新編譯執行，提升開發效率。\n\n2. 設定資料庫連接下載專案後開啟，等候 IntelliJ 或 Eclipse 完成建置。  \n進入 src/main/resources/application.properties，新增以下設定內容：\n# 資料庫連接spring.datasource.url=jdbc:h2:mem:todo_dbspring.datasource.driver-class-name=org.h2.Driverspring.datasource.username=saspring.datasource.password=password# 啟用 H2 資料庫控制台spring.h2.console.enabled=truespring.h2.console.path=/h2# JPA 和 Hibernate 設定spring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=true\n\n參數說明\n**spring.datasource.url**：定義要連接的資料庫，mem 表示儲存在記憶體中，todo_db 是資料庫名稱。\n**spring.datasource.username &amp; spring.datasource.password**：定義使用者名稱和密碼。H2 允許自定義這些值，在這裡分別設定為 sa 和 password。\n**spring.h2.console.enabled**：開啟 H2 資料庫的瀏覽器控制台。\n**spring.h2.console.path**：指定控制台的存取路徑為 /h2。\n**spring.jpa.hibernate.ddl-auto=update**：自動同步資料表結構與程式內的 ORM 模型。\n**spring.jpa.show-sql=true**：讓 SQL 指令顯示在控制台中，方便除錯。\n\n\n3. 啟動專案並驗證連接完成設定後，啟動專案。在瀏覽器中前往 http://localhost:8080/h2。  \n輸入以下資訊來登入資料庫管理介面：  \n\nJDBC URL：jdbc:h2:mem:todo_db  \nUser Name：sa  \nPassword：password\n\n點擊 Connect 進入管理頁面，確認專案與資料庫連接正常。  \n\n\n4. 測試與後續開發專案啟動成功後，我們可以繼續進行資料表的設計與資料操作測試。若 ORM 模型變更，系統會自動更新資料表結構，無須手動調整。\n\n這樣就完成了專案的初始設置，我們可以進一步撰寫資料模型與 API 來擴展功能。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API"]},{"title":"Spring Boot project-oriented programming（3）API專案 概念","url":"/2024/10/12/spring-boot-pop-03/","content":"接下來，我們將深入探討 Spring Boot 的應用。大多數 Spring Boot 專案都涉及 RESTful API 的開發，可以說，學會如何完成一個 RESTful API 專案，就相當於掌握了許多 Spring Boot 專案的核心。\n我們這次的 RESTful API 專案是一個待辦事項清單（Todo List），也就是「待辦事項系統」。大家可以思考這個專案應具備哪些功能，以下是我的設計思路，供各位參考。\n設計思路這個專案的核心部分是待辦事項（Todo）。我們應該如何設計這個待辦事項呢？\nTodo 項目每個待辦事項應該包含以下幾個要素：\n\n一個唯一的 id 以便於資料庫查詢\n一個 title 用來描述待辦的事項\n一個 completed 用來表示該事項是否已完成\n\n專案功能接著，我們進行功能規劃：\n\n新增 Todo\n待辦事項清單必然需要新增事項的功能，這部分的資料應透過 JSON 格式傳送，而不是 URL。因為 URL 的長度限制為 1024 字元，若 title 過長（例如，肌聯蛋白，其全名包含 189819 個字母），則會導致資料截斷。使用 JSON 傳送資料則不會有這個問題。\n功能路徑：/\n\n查看所有 Todo\n當我們新增了待辦事項後，通常會想檢視它們是否成功儲存在資料庫中，因此這項功能非常重要。\n功能路徑：/all\n\n查看特定 id 的 Todo\n有時候我們只需要查詢單一待辦事項，可以透過 URL 傳送 id，而這個 id 不會超過 1024 字元。\n功能路徑：/&#123;id&#125;\n\n刪除特定 id 的 Todo\n既然有新增功能，自然也會有刪除功能。刪除時需要指定 id，以防不小心刪除所有事項。\n功能路徑：/&#123;id&#125;\n\n修改特定 id 的 Todo\n當新增時出現錯誤或需要更新資訊時，我們應該能修改待辦事項的內容，資料透過 JSON 傳送。\n功能路徑：/&#123;id&#125;\n\n標記 Todo 為完成\n當某項待辦事項完成時，需要有一個功能來標記它已完成，這可以透過 URL 傳送 id。\n功能路徑：/&#123;id&#125;/completed\n\n標記 Todo 為未完成\n既然有標記為完成的功能，當然也需要標記為未完成的功能，同樣透過 URL 傳送 id。\n功能路徑：/&#123;id&#125;/uncompleted\n\n\n這些基本功能幾乎完成了專案的 50%，接下來只剩實作部分。有些人可能會疑惑這些設計和專案的關係，接下來我會用表格的形式來幫助大家理解這些功能設計。\nEntity 格式與專案功能Todo Entity 格式\n\n\n欄位名稱\n資料型態\n說明\n\n\n\nid\nLong\n唯一的 id，方便資料庫查詢\n\n\ntitle\nString\n用來描述待辦事項\n\n\ncompleted\nBoolean\n表示是否已完成\n\n\n專案功能對應表\n\n\n路徑\nHTTP Request Method\n功能說明\nRequest Body\n\n\n\n&#x2F;\nPOST\n新增 Todo\nTodo\n\n\n&#x2F;all\nGET\n查看所有待辦事項\n無\n\n\n&#x2F;{id}\nGET\n查看指定 id 的 Todo\n無\n\n\n&#x2F;{id}\nDELETE\n刪除指定 id 的 Todo\n無\n\n\n&#x2F;{id}\nPUT\n修改指定 id 的 Todo\nTodo\n\n\n&#x2F;{id}&#x2F;completed\nPATCH\n標記 Todo 為完成\n無\n\n\n&#x2F;{id}&#x2F;uncompleted\nPATCH\n標記 Todo 為未完成\n無\n\n\n在這裡，Request Body 是用來傳輸 Todo 內容至專案中的。\nRESTful API 的核心有些人可能會認為路徑設計有些重複，但其實是透過不同的 HTTP request method 來區分不同的功能。\nRESTful API 的核心理念是根據 HTTP request method 和 URL 來決定不同的操作結果。舉例來說，就像垃圾分類桶一樣，雖然是同一個桶子（URL），但根據不同的入口（HTTP request method），垃圾會被分類成資源回收或一般垃圾（例如：查看、刪除或修改指定 id 的待辦事項）。\n\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API"]},{"title":"Spring Boot project-oriented programming（5）API專案 實作","url":"/2024/10/14/spring-boot-pop-05/","content":"完成資料庫連接後的下一步：實作\n在上一部分，我們已經完成了與資料庫的連接。本篇將進一步實作概念篇中設計的功能。\n\n1. 建立 Todo 實體類別路徑：src/main/java/com/restufulapi/restfulapi/Entity請先在該路徑下新增 Todo.java。若該資料夾 Entity 不存在，可以手動建立。此後如遇類似情況，也請使用相同處理方式。\n定義 Todo 實體\n註冊為 Spring 的 Entity\n@Entitypublic class Todo &#123;\n\n設定主鍵 ID 與自動遞增\n@Id@GeneratedValue(strategy = GenerationType.IDENTITY)private Long id;private String title;private boolean completed;\n\n建立建構子與存取方法（Getter&#x2F;Setter）\npublic Todo() &#123;&#125;public Todo(Long id, String title, boolean completed) &#123;    this.id = id;    this.title = title;    this.completed = completed;&#125;public Long getId() &#123; return id; &#125;public void setId(Long id) &#123; this.id = id; &#125;public String getTitle() &#123; return title; &#125;public void setTitle(String title) &#123; this.title = title; &#125;public boolean isCompleted() &#123; return completed; &#125;public void setCompleted(boolean completed) &#123; this.completed = completed; &#125;&#125;\n\n使用 IntelliJ 生成建構子與 Getter&#x2F;Setter\n\n右鍵 completed 之下的空白處 → 選擇 Generate → 點擊 Constructor。\n先按 Select None，生成無參數的建構子。\n重複相同步驟，並選取 id、title、completed，生成帶參數的建構子。\n接著再選擇 Getter and Setter，針對上述三個欄位生成對應的方法。\n\n\n\n\n2. 建立 Repository 類別路徑：src/main/java/com/restufulapi/restfulapi/Repository新增 TodoRepository.java 並選擇 Interface，這個介面負責資料存取操作。\n程式碼：\npublic interface TodoRepository extends JpaRepository&lt;Todo, Long&gt; &#123;&#125;\n\n說明：\n\n繼承 JpaRepository&lt;Todo, Long&gt; 提供基本的增刪改查、分頁與排序功能。\n\n\n3. 建立 Service 類別不拆分 Service 和 ServiceImpl 的理由在其他教學中，你可能看過拆分 Service 和 ServiceImpl 的設計。這樣做是為了未來可能有相同介面、不同實作的需求。但在此案例中，額外拆分顯得不必要且浪費時間。\n為什麼將邏輯寫在 Service 層雖然這是個小專案，理論上可以將邏輯直接寫在 Controller，但大型專案中會有多個 Controller 使用同一 Service，將邏輯集中在 Service 層可避免重複程式碼，且方便管理輸入&#x2F;輸出的資料結構。\n建立 TodoService.java：\n@Servicepublic class TodoService &#123;    private final TodoRepository todoRepository;    public TodoService(TodoRepository todoRepository) &#123;        this.todoRepository = todoRepository;    &#125;    public Todo addTodo(Todo todo) &#123;        return todoRepository.save(todo);    &#125;    public List&lt;Todo&gt; getAllTodos() &#123;        return todoRepository.findAll();    &#125;    public Todo getTodoById(Long id) &#123;        return findOrElseThrow(id);    &#125;    public void deleteTodo(Long id) &#123;        Todo todo = findOrElseThrow(id);        todoRepository.delete(todo);    &#125;    public Todo updateTodo(Todo todo) &#123;        Todo oldTodo = findOrElseThrow(todo.getId());        oldTodo.setTitle(todo.getTitle() == null ? oldTodo.getTitle() : todo.getTitle());        oldTodo.setCompleted(todo.isCompleted());        return todoRepository.save(oldTodo);    &#125;    public Todo setCompleteTodo(Long id) &#123;        Todo oldTodo = findOrElseThrow(id);        oldTodo.setCompleted(true);        return todoRepository.save(oldTodo);    &#125;    public Todo setUncompleteTodo(Long id) &#123;        Todo oldTodo = findOrElseThrow(id);        oldTodo.setCompleted(false);        return todoRepository.save(oldTodo);    &#125;    private Todo findOrElseThrow(Long id) &#123;        return todoRepository.findById(id)                .orElseThrow(() -&gt; new RuntimeException(&quot;Todo not found with id: &quot; + id));    &#125;&#125;\n\n\n4. 建立 Controller 類別路徑：src/main/java/com/restufulapi/restfulapi/Controller新增 TodoController.java，該類別負責處理外部請求，並將結果回傳。\n程式碼：\n@RestController@RequestMapping(&quot;/api/todo&quot;)public class TodoController &#123;    private final TodoService todoService;    public TodoController(TodoService todoService) &#123;        this.todoService = todoService;    &#125;    @PostMapping(&quot;/&quot;)    public Todo addTodo(@RequestBody Todo todo) &#123;        return todoService.addTodo(todo);    &#125;    @GetMapping(&quot;/all&quot;)    public List&lt;Todo&gt; getAllTodos() &#123;        return todoService.getAllTodos();    &#125;    @GetMapping(&quot;/&#123;id&#125;&quot;)    public Todo getTodo(@PathVariable(&quot;id&quot;) Long id) &#123;        return todoService.getTodoById(id);    &#125;    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public String deleteTodo(@PathVariable(&quot;id&quot;) Long id) &#123;        todoService.deleteTodo(id);        return &quot;Todo deleted successfully&quot;;    &#125;    @PutMapping(&quot;/&#123;id&#125;&quot;)    public Todo updateTodo(@PathVariable(&quot;id&quot;) Long id, @RequestBody Todo todo) &#123;        todo.setId(id);        return todoService.updateTodo(todo);    &#125;    @PatchMapping(&quot;/&#123;id&#125;/completed&quot;)    public Todo completeTodo(@PathVariable(&quot;id&quot;) Long id) &#123;        return todoService.setCompleteTodo(id);    &#125;    @PatchMapping(&quot;/&#123;id&#125;/uncompleted&quot;)    public Todo incompleteTodo(@PathVariable(&quot;id&quot;) Long id) &#123;        return todoService.setUncompleteTodo(id);    &#125;&#125;\n\n\n5. 啟動專案啟動專案後，你會在 Console 中看到 Hibernate 產生的 SQL 語句。Spring Data JPA 自動完成了資料表的映射與操作。\n\n6. 完整程式碼專案完整程式碼可從以下連結下載：完整程式碼下載 \n\n這篇教學帶你從資料庫連接、實體設計，到 Service 和 Controller 的完整實作。使用此架構，你可以快速完成基本的 RESTful API。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API"]},{"title":"Spring Boot project-oriented programming（7）使用 MariaDB 打造RESTful API專案：從安裝到 CRUD 教學","url":"/2024/10/16/spring-boot-pop-07/","content":"前言我們先前的專案使用 H2 資料庫，但遇到了一個重大問題：專案關閉後，資料庫中的資料就會消失。  \n因此，本次我們將改用需要安裝的資料庫，這樣資料能長期保存，即使關機也不會消失，只要我們不主動刪除，就能永久保存。  \n談到資料庫，許多人會想到 MySQL，因為它曾與 Java 一樣，隸屬於 Oracle。然而，我們這次的專案並不會使用 MySQL。\n為什麼避開 MySQL？回顧過去，Oracle 曾免費提供 Oracle JDK 給所有人與企業使用，但某天突然宣布 Oracle JDK 改為收費，不付費就會收到律師警告信。雖然 Oracle 另外提供了免費的 OpenJDK，但這個轉變導致許多企業改用自己的 OpenJDK，避免被收費。\n由此可見，若選用 MySQL，未來也有可能會遭遇類似情況。為了避免這種風險，我們將改用 MariaDB。\n\nMariaDB 安裝與建立資料庫MariaDB 是一個開源且可免費商用的資料庫，由部分原 MySQL 開發團隊創建。它與 MySQL 高度相容，對開發者來說幾乎沒有學習障礙。  \n\n下載與安裝 MariaDB前往 官網下載 MariaDB 。安裝時保持預設設定，並記下設定的 root 密碼，稍後我們會用到。  \n\n使用 HeidiSQL 連線 MariaDB安裝完成後，打開 HeidiSQL，輸入之前設定的 root 密碼並連線。\n\n建立資料庫在 HeidiSQL 的查詢介面輸入以下指令並按下 F9：  \n   CREATE DATABASE book;   ```  4. **檢視資料庫**     按下 F5 更新，可以在左側看到剛建立的 `book` 資料庫。  ---# Entity 格式與專案功能  **`Book` Entity 格式：**| 欄位名稱 | 資料型態 | 說明                 || -------- | -------- | -------------------- || id       | Long     | 唯一識別碼，便於查詢 || name     | String   | 書名                 || page     | Integer  | 頁數                 |**專案功能：**| 路徑     | HTTP Method | 說明                | Request Body || -------- | ----------- | ------------------- | ------------ || `/`      | POST        | 新增書籍            | Book         || `/all`   | GET         | 取得全部書籍        | 無           || `/&#123;id&#125;`  | GET         | 取得指定書籍        | 無           || `/&#123;id&#125;`  | PUT         | 修改書籍資料        | Book         || `/&#123;id&#125;`  | DELETE      | 刪除指定書籍        | 無           |---# 建立專案並連接資料庫  1. 前往 [Spring Initializr](https://start.spring.io) 建立專案，參考下圖進行設定：     ![](https://images2.imgbox.com/27/7b/wrQ4NZX7_o.png)  2. 下載並開啟專案。在上一個專案中，我們發現 `application.properties` 內部有許多重複的設定。本次我們將改用 **YAML 格式**，讓設定更為簡潔。## YAML 格式設定將 `application.properties` 改為 `application.yaml`，內容如下：```yamlspring:  application:    name: Book-Management-Project  datasource:    url: jdbc:mariadb://localhost:3306/book    driver-class-name: org.mariadb.jdbc.Driver    username: root    password: 密碼  # 這裡填入安裝時設定的 root 密碼  jpa:    hibernate:      ddl-auto: update    show-sql: true\n\n注意： YAML 格式對縮排非常敏感，請務必正確對齊。  \n\n實作專案的各個層級Entity@Entitypublic class Book &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String name;    private int page;    public Book() &#123;&#125;    public Book(Long id, String name, int page) &#123;        this.id = id;        this.name = name;        this.page = page;    &#125;    // Getters and Setters 略&#125;\n\nRepositorypublic interface BookRepository extends JpaRepository&lt;Book, Long&gt; &#123;&#125;\n\nService@Servicepublic class BookService &#123;    private final BookRepository bookRepository;    public BookService(BookRepository bookRepository) &#123;        this.bookRepository = bookRepository;    &#125;    public Book addBook(Book book) &#123;        return bookRepository.save(book);    &#125;    public List&lt;Book&gt; getAllBooks() &#123;        return bookRepository.findAll();    &#125;    public Book getBookById(Long id) &#123;        return bookRepository.findById(id).orElse(null);    &#125;    public Book updateBook(Book book) &#123;        return bookRepository.findById(book.getId()).map(existingBook -&gt; &#123;            existingBook.setName(book.getName() != null ? book.getName() : existingBook.getName());            existingBook.setPage(book.getPage());            return bookRepository.save(existingBook);        &#125;).orElse(null);    &#125;    public void deleteBookById(Long id) &#123;        bookRepository.findById(id).ifPresent(book -&gt; bookRepository.deleteById(book.getId()));    &#125;&#125;\n\nController@RestController@RequestMapping(&quot;/api/book&quot;)public class BookController &#123;    private final BookService bookService;    public BookController(BookService bookService) &#123;        this.bookService = bookService;    &#125;    @PostMapping(&quot;/&quot;)    public ResponseEntity&lt;Book&gt; addBook(@RequestBody Book book) &#123;        return new ResponseEntity&lt;&gt;(bookService.addBook(book), HttpStatus.CREATED);    &#125;    @GetMapping(&quot;/all&quot;)    public ResponseEntity&lt;List&lt;Book&gt;&gt; getAllBooks() &#123;        return ResponseEntity.ok(bookService.getAllBooks());    &#125;    @GetMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;Book&gt; getBookById(@PathVariable Long id) &#123;        return ResponseEntity.ok(bookService.getBookById(id));    &#125;    @PutMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;Book&gt; updateBook(@PathVariable Long id, @RequestBody Book book) &#123;        book.setId(id);        return ResponseEntity.ok(bookService.updateBook(book));    &#125;    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;String&gt; deleteBook(@PathVariable Long id) &#123;        bookService.deleteBookById(id);        return ResponseEntity.ok(&quot;Book deleted successfully&quot;);    &#125;&#125;\n\n\n測試專案\n使用 Hoppscotch 測試 API。\n\n\nCreate book\n\nGet all books\n\nGet book by id\n\nUpdate book\n\nDelete book by id\n\n\n\n程式碼與測試工具\n專案下載：點此下載專案\n測試工具範例：點此下載測試範例\n\n以上即為完整的 MariaDB 連接與 CRUD 專案開發流程。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","MariaDB"]},{"title":"Spring Boot project-oriented programming（6）API專案 測試","url":"/2024/10/15/spring-boot-pop-06/","content":"專案測試與部署指南功能測試專案已完成，接下來需測試各個功能以確保正常運作。注意：  \n\n每次專案重新啟動時，資料庫的內容將會重置。  \n若使用 Spring Boot DevTools，修改並儲存程式碼後會自動重啟專案，同時清除資料。\n\n\n使用 Hoppscotch 測試 RESTful API我們將使用 Hoppscotch 測試 API 功能。相比於需要登入的 Postman，我更推薦 Hoppscotch，因其更簡單直接。  \n\nHoppscotch 網頁版  \nChrome 擴充套件\n\n為了方便測試，這裡提供一個預先設定好的檔案供下載：API 測試範例下載。  \n\n匯入範例設定\n在 Hoppscotch 左側點擊 資料夾圖示。  \n\n選擇 Import from Hoppscotch。  \n\n匯入下載的 JSON 檔案後，按 Import。  \n\n你將會看到 todo 資料夾，點開即可查看 API 測試範例。\n\n\n\nAPI 測試操作1. Create Todo\n點選 Create todo，按 Send 即可新增 todo。  \n在 Body 區域可看到 title 和 completed，你可以嘗試修改後再發送觀察變化。\n\n2. Get All Todos\n切換到 Get all todos，按 Send 即可取得所有 todo。若先前多次新增，這裡會顯示多筆資料。\n\n3. Get Todo by ID\n點選 Get todo by id 並按 Send，可取得指定 ID 的 todo。\n\n4. Update Todo\n在 Update todo 中修改資料，按 Send 可更新 todo 的內容。\n\n5. Set Todo Completed &#x2F; Uncompleted\n使用 Set todo completed 和 Set todo uncompleted 來變更狀態。\n\n6. Delete Todo by ID\n在 Delete todo by id 中按 Send，可刪除指定 ID 的 todo。\n\n\n專案打包成 JAR 檔為了部署方便，我們將專案打包成 JAR 檔，避免使用 GUI 介面和減少 RAM 佔用。這對於 1GB RAM VPS 特別重要，因為在低資源環境下，無法有效使用像 IDEA 這樣的開發工具。  \n打包流程\n在 IDEA 右側選擇 m 並展開 restfulapi → Plugins → clean。  \n\n連按兩次 clean.clean 清理舊的 target 資料。  \n\n展開 Lifecycle，連按兩次 package 打包成 JAR 檔案。\n\n\nJAR 檔會出現在專案的 target 資料夾中：  \ntarget/restfulapi-0.0.1-SNAPSHOT.jar\n\n啟動 JAR 檔在命令提示字元中進入 target 資料夾後輸入：  \njava -jar restfulapi-0.0.1-SNAPSHOT.jar\n\n將 JAR 檔上傳至 Linux VPS 伺服器後，也可用相同指令啟動。  \n\n在 Linux 安裝 JDK以下的方式可在 Debian 和 Redhat 系統上安裝 Amazon Corretto JDK：  \n\n下載 JDK  \nwget https://corretto.aws/downloads/latest/amazon-corretto-17-x64-linux-jdk.tar.gz\n\n\n解壓縮檔案  \ntar -zxvf amazon-corretto-17-x64-linux-jdk.tar.gz\n\n\n移動至 &#x2F;usr&#x2F;share 目錄  \nsudo mv amazon-corretto-17.0.12.7.1-linux-x64 /usr/share\n\n\n設定環境變數編輯 ~/.bashrc：  \nsudo nano ~/.bashrc\n\n在最後新增以下兩行：  \nexport JAVA_HOME=/usr/share/amazon-corretto-17.0.12.7.1-linux-x64\nexport PATH=$JAVA_HOME/bin:$PATH\n\n\n按 Ctrl+O 儲存並按 Enter 確認。  \n按 Ctrl+X 退出編輯器。\n\n\n啟用環境變數  \nsource ~/.bashrc\n\n\n啟動專案  \njava -jar restfulapi-0.0.1-SNAPSHOT.jar\n\n\n\n\n透過上述步驟，你就能順利測試和部署專案，並在 VPS 上運行應用程式。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API"]},{"title":"Spring Boot project-oriented programming（8）使用MongoDB打造全端專案 規劃","url":"/2024/10/17/spring-boot-pop-08/","content":"我們已經完成了兩個專案（不包含Hello World），這些專案皆透過API測試工具 Hoppscotch 進行測試與驗證。本次專案將進一步提升使用者的操作體驗，取消API測試工具的依賴，並改以網頁介面進行資料的新增、修改和刪除操作。\n我們將採用性能更佳的 MongoDB 作為資料庫系統，它是一種NoSQL資料庫，能以文件形式儲存資料，簡化了資料結構與設計。\n\n專案介紹此專案的目標是建立一個全端的客戶管理系統，包含前端和後端開發。我們將以MongoDB為基礎儲存資料，並使用Spring Boot框架處理系統邏輯及與資料庫的互動。\n\nDocument格式與專案功能設計Customer 資料結構\n\n\n欄位名稱\n資料型態\n說明\n\n\n\nid\nString\n唯一的識別碼，使用UUID\n\n\nfirstName\nString\n名\n\n\nlastName\nString\n姓\n\n\nemail\nString\n電子信箱\n\n\n\nAPI 路由與功能\n\n\n路徑\nHTTP方法\n說明\n\n\n\n/\nGET\n取得全部客戶資料\n\n\n/new\nGET\n顯示新增客戶的頁面\n\n\n/new\nPOST\n新增客戶資料\n\n\n/view/&#123;id&#125;\nGET\n查看單一客戶的詳細資料\n\n\n/update/&#123;id&#125;\nGET\n顯示修改客戶資料的頁面\n\n\n/update/&#123;id&#125;\nPOST\n更新客戶資料\n\n\n/delete/&#123;id&#125;\nGET\n刪除客戶資料\n\n\n\n安裝MongoDB及建立資料庫完成專案設計後，請下載並安裝 MongoDB Compass (GUI) ，以便更直觀地管理MongoDB資料。  \n\n啟動MongoDB Compass，點擊 Connect 連接資料庫。  \n  \n\n在側邊欄點擊「**+**」，新增資料庫。  \n  \n\n在Database Name和Collection Name輸入「customer」。  \n\n按下 Create Database，完成資料庫的建立，專門儲存客戶資料。  \n\n\n\n\n專案開發與資料庫連接建立專案時，請根據以下相依性進行設定：  \n  \n我們熟悉前兩個依賴項目，而以下是專案中新增的兩個：  \n\nSpring Data MongoDB類似於Spring Data JPA，Spring Data MongoDB簡化了與MongoDB的互動，不需手動撰寫SQL語句即可操作資料庫。  \n\nValidation用來驗證資料格式。本專案會檢查firstName、lastName和email是否為空，並確保email符合正確的電子郵件格式。  \n\nThymeleaf這是一個模板引擎，用於處理前端網頁的呈現，支援HTML、JavaScript及CSS，並將資料動態顯示於瀏覽器中。\n\n\n\n配置資料庫連線下載並開啟專案，在src/main/resources/application.properties中新增以下內容：  \nspring.data.mongodb.uri=mongodb://localhost:27017/customer\n\n啟動專案，確認系統能順利連接至MongoDB並正常運行。  \n\n這個專案將帶領我們進一步了解MongoDB與Spring Boot的整合，讓我們在全端開發的技能上更上一層樓。準備好後，我們就可以開始撰寫程式碼，構建完整的客戶管理系統。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","MongoDB"]},{"title":"Spring Boot project-oriented programming（9）使用MongoDB打造全端專案 後端與UUID介紹","url":"/2024/10/18/spring-boot-pop-09/","content":"Document在 NoSQL 中，我們以 document 代替 entity 來代表資料物件。  \n@Document 註解中的 collection 屬性，用來指定對應的資料集合名稱。\n// Customer.java@Document(collection = &quot;customer&quot;)public class Customer &#123;    @Id    private String id;\n\n當某些欄位為空時，系統會拋出錯誤，message 屬性用於向前端顯示提示訊息：\n@NotEmpty(message = &quot;名字為必填欄位&quot;)private String firstName;@NotEmpty(message = &quot;姓氏為必填欄位&quot;)private String lastName;@NotEmpty(message = &quot;Email為必填欄位&quot;)@Email(message = &quot;請輸入有效的Email格式&quot;)private String email;\n\nConstructor 和 Getter&#x2F;Setterpublic Customer() &#123;&#125;public Customer(String id, String firstName, String lastName, String email) &#123;    this.id = id;    this.firstName = firstName;    this.lastName = lastName;    this.email = email;&#125;// Getter and Setter methods...\n\n為什麼使用 String 作為 ID在 MongoDB 中，預設的 ID 格式為 UUID (Universally Unique Identifier)，例如 560266b0-2bf0-4241-a578-66efb7c3ec80。UUID 的優勢在於大幅降低 ID 重複的可能性。  \nID 重複 (Collision) 的風險使用傳統自動遞增的 ID，在高併發系統中容易產生重複。例如，如果多個使用者在同一毫秒內新增資料，可能會導致 ID 碰撞，進而使資料庫拒絕請求並引發錯誤，最終造成系統不穩定。\nCollision 的解決方案UUID 採用隨機生成方式，避免同一時間內產生相同的 ID。需要每秒產生 10 億個 UUID 並持續 85 年才會發生一次碰撞，發生碰撞的機率仍非常低。\nUUID 的缺點UUID 的隨機性雖然解決了碰撞問題，但會降低查詢效能，因為無法預測或快速定位某個 UUID 是否已存在資料庫中。\n傳統 ID vs UUID\n\n\n項目\n傳統 ID\nUUID\n\n\n\n優點\n查詢速度快，ID 遞增且可預測\n碰撞機率極低\n\n\n缺點\n高併發時容易碰撞\n查詢速度較慢\n\n\n\nRepository使用 MongoRepository 來與 MongoDB 互動。這與使用 Spring Data JPA 的方式類似，但這裡改為繼承 MongoRepository。\n// CustomerRepository.javapublic interface CustomerRepository extends MongoRepository&lt;Customer, String&gt; &#123;&#125;\n\n\nService在服務層，我們實作了建立、查詢、修改及刪除客戶的功能。\n// CustomerService.java@Servicepublic class CustomerService &#123;    private final CustomerRepository customerRepository;    public CustomerService(CustomerRepository customerRepository) &#123;        this.customerRepository = customerRepository;    &#125;    // 建立客戶    public void createCustomer(Customer customer) &#123;        customerRepository.save(customer);    &#125;    // 查詢所有客戶    public List&lt;Customer&gt; getAllCustomers() &#123;        return customerRepository.findAll();    &#125;    // 查詢指定 ID 的客戶    public Customer getCustomerById(String id) &#123;        return customerRepository.findById(id).orElse(null);    &#125;    // 修改客戶    public void updateCustomer(Customer customer) &#123;        Customer oldCustomer = customerRepository.findById(customer.getId()).orElse(null);        if (oldCustomer != null) &#123;            oldCustomer.setFirstName(customer.getFirstName());            oldCustomer.setLastName(customer.getLastName());            oldCustomer.setEmail(customer.getEmail());            customerRepository.save(oldCustomer);        &#125;    &#125;    // 刪除客戶    public void deleteCustomer(String id) &#123;        customerRepository.deleteById(id);    &#125;&#125;\n\n\nController在此專案中，我們使用 @Controller 來搭配 Thymeleaf 呈現網頁內容。\n// CustomerController.java@Controllerpublic class CustomerController &#123;    private final CustomerService customerService;    public CustomerController(CustomerService customerService) &#123;        this.customerService = customerService;    &#125;    // 顯示所有客戶    @GetMapping(&quot;/&quot;)    public String listCustomers(Model model) &#123;        List&lt;Customer&gt; customers = customerService.getAllCustomers();        model.addAttribute(&quot;customers&quot;, customers);        return &quot;index&quot;;    &#125;    // 顯示新增客戶頁面    @GetMapping(&quot;/new&quot;)    public String newCustomer(Model model) &#123;        model.addAttribute(&quot;customer&quot;, new Customer());        return &quot;new_customer&quot;;    &#125;    // 儲存新增客戶    @PostMapping(&quot;/new&quot;)    public String saveCustomer(@Valid @ModelAttribute(&quot;customer&quot;) Customer customer,                               BindingResult bindingResult, Model model) &#123;        if (bindingResult.hasErrors()) &#123;            model.addAttribute(&quot;customer&quot;, customer);            return &quot;new_customer&quot;;        &#125;        customerService.createCustomer(customer);        return &quot;redirect:/&quot;;    &#125;    // 顯示單一客戶資訊    @GetMapping(&quot;/view/&#123;id&#125;&quot;)    public String viewCustomer(@PathVariable(&quot;id&quot;) String id, Model model) &#123;        model.addAttribute(&quot;customer&quot;, customerService.getCustomerById(id));        return &quot;view_customer&quot;;    &#125;    // 顯示編輯客戶頁面    @GetMapping(&quot;/edit/&#123;id&#125;&quot;)    public String editCustomer(@PathVariable(&quot;id&quot;) String id, Model model) &#123;        model.addAttribute(&quot;customer&quot;, customerService.getCustomerById(id));        return &quot;edit_customer&quot;;    &#125;    // 儲存編輯後的客戶資料    @PostMapping(&quot;/edit/&#123;id&#125;&quot;)    public String updateCustomer(@Valid @ModelAttribute(&quot;customer&quot;) Customer customer,                                 BindingResult bindingResult, Model model) &#123;        if (bindingResult.hasErrors()) &#123;            model.addAttribute(&quot;customer&quot;, customer);            return &quot;edit_customer&quot;;        &#125;        customerService.updateCustomer(customer);        return &quot;redirect:/&quot;;    &#125;    // 刪除客戶    @GetMapping(&quot;/delete/&#123;id&#125;&quot;)    public String deleteCustomer(@PathVariable(&quot;id&quot;) String id) &#123;        customerService.deleteCustomer(id);        return &quot;redirect:/&quot;;    &#125;&#125;\n\n\n注意：在使用 Thymeleaf 時，HTML 檔案需存放在 src/main/resources/templates 目錄下。例如，index.html 會對應到 Controller 中的 return &quot;index&quot;。\n\n\n這個專案示範了如何整合 Spring Boot、MongoDB、及 Thymeleaf，並展示了前後端資料交換的流程。使用 Thymeleaf 除了編寫前端頁面外，也需透過 Controller 將資料傳遞至前端，讓整個系統更加完整。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","MongoDB"]},{"title":"Spring Boot project-oriented programming（10）使用MongoDB打造全端專案 前端與測試","url":"/2024/10/19/spring-boot-pop-10/","content":"由於專案採用了 Thymeleaf 作為模板引擎，因此所有前端頁面內容應放置於 src/main/resources/templates 目錄下。\n以下逐步介紹不同頁面設計與 Thymeleaf 功能的使用方式，並輔以測試操作說明。\n\n1. index.html：顯示客戶列表說明\n使用 &lt;tr th:each&gt; 迴圈將後端傳來的客戶清單逐一顯示於頁面中。\n使用 $&#123;&#125; 來綁定資料模型，例如 $&#123;customer.id&#125; 用於顯示客戶 ID。\n使用 th:href 動態生成連結。\n\n範例程式碼&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Customer Management System&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;a th:href=&quot;@&#123;/&#125;&quot;&gt;Home&lt;/a&gt;    &lt;a th:href=&quot;@&#123;/new&#125;&quot;&gt;Add New Customer&lt;/a&gt;&lt;/div&gt;&lt;div&gt;    &lt;h1&gt;List of Customers&lt;/h1&gt;    &lt;table&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;Customer ID&lt;/th&gt;                &lt;th&gt;First Name&lt;/th&gt;                &lt;th&gt;Last Name&lt;/th&gt;                &lt;th&gt;Email&lt;/th&gt;                &lt;th&gt;Actions&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;tr th:each=&quot;customer : $&#123;customers&#125;&quot;&gt;                &lt;td th:text=&quot;$&#123;customer.id&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;$&#123;customer.firstName&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;$&#123;customer.lastName&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;$&#123;customer.email&#125;&quot;&gt;&lt;/td&gt;                &lt;td&gt;                    &lt;a th:href=&quot;@&#123;&#x27;/view/&#x27; + $&#123;customer.id&#125;&#125;&quot;&gt;View&lt;/a&gt;                    &lt;a th:href=&quot;@&#123;&#x27;/edit/&#x27; + $&#123;customer.id&#125;&#125;&quot;&gt;Edit&lt;/a&gt;                    &lt;a th:href=&quot;@&#123;&#x27;/delete/&#x27; + $&#123;customer.id&#125;&#125;&quot;&gt;Delete&lt;/a&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;    &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n2. new_customer.html：新增客戶資料說明\n使用 &lt;form&gt; 元素透過 th:action 將表單資料送至後端。\n使用 th:field 綁定資料模型屬性，如 *&#123;firstName&#125;。\n使用 th:if 判斷欄位錯誤，並顯示相應錯誤訊息。\n\n範例程式碼&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Create New Customer&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;a th:href=&quot;@&#123;/&#125;&quot;&gt;Home&lt;/a&gt;&lt;/div&gt;&lt;h1&gt;Create New Customer&lt;/h1&gt;&lt;form method=&quot;post&quot; th:action=&quot;@&#123;/new&#125;&quot; th:object=&quot;$&#123;customer&#125;&quot;&gt;    &lt;label&gt;First Name&lt;/label&gt;    &lt;input type=&quot;text&quot; th:field=&quot;*&#123;firstName&#125;&quot; placeholder=&quot;Enter customer first name&quot;/&gt;    &lt;p th:if=&quot;$&#123;#fields.hasErrors(&#x27;firstName&#x27;)&#125;&quot; th:errors=&quot;*&#123;firstName&#125;&quot;&gt;&lt;/p&gt;    &lt;label&gt;Last Name&lt;/label&gt;    &lt;input type=&quot;text&quot; th:field=&quot;*&#123;lastName&#125;&quot; placeholder=&quot;Enter customer last name&quot;/&gt;    &lt;p th:if=&quot;$&#123;#fields.hasErrors(&#x27;lastName&#x27;)&#125;&quot; th:errors=&quot;*&#123;lastName&#125;&quot;&gt;&lt;/p&gt;    &lt;label&gt;Email&lt;/label&gt;    &lt;input type=&quot;text&quot; th:field=&quot;*&#123;email&#125;&quot; placeholder=&quot;Enter customer email&quot;/&gt;    &lt;p th:if=&quot;$&#123;#fields.hasErrors(&#x27;email&#x27;)&#125;&quot; th:errors=&quot;*&#123;email&#125;&quot;&gt;&lt;/p&gt;    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n3. edit_customer.html：修改客戶資料說明\n透過 th:action 將修改後的資料送至 /edit/&#123;id&#125;。\n同樣使用 th:field 與 th:errors 進行欄位綁定與錯誤提示。\n\n範例程式碼&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Edit Customer&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;a th:href=&quot;@&#123;/&#125;&quot;&gt;Home&lt;/a&gt;&lt;/div&gt;&lt;h1&gt;Edit Customer&lt;/h1&gt;&lt;form method=&quot;post&quot; th:action=&quot;@&#123;&#x27;/edit/&#x27; + $&#123;customer.id&#125;&#125;&quot; th:object=&quot;$&#123;customer&#125;&quot;&gt;    &lt;label&gt;First Name&lt;/label&gt;    &lt;input type=&quot;text&quot; th:field=&quot;*&#123;firstName&#125;&quot;/&gt;    &lt;p th:if=&quot;$&#123;#fields.hasErrors(&#x27;firstName&#x27;)&#125;&quot; th:errors=&quot;*&#123;firstName&#125;&quot;&gt;&lt;/p&gt;    &lt;label&gt;Last Name&lt;/label&gt;    &lt;input type=&quot;text&quot; th:field=&quot;*&#123;lastName&#125;&quot;/&gt;    &lt;p th:if=&quot;$&#123;#fields.hasErrors(&#x27;lastName&#x27;)&#125;&quot; th:errors=&quot;*&#123;lastName&#125;&quot;&gt;&lt;/p&gt;    &lt;label&gt;Email&lt;/label&gt;    &lt;input type=&quot;text&quot; th:field=&quot;*&#123;email&#125;&quot;/&gt;    &lt;p th:if=&quot;$&#123;#fields.hasErrors(&#x27;email&#x27;)&#125;&quot; th:errors=&quot;*&#123;email&#125;&quot;&gt;&lt;/p&gt;    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n4. view_customer.html：檢視客戶資料說明\n使用 th:text 顯示客戶的詳細資料。\n\n範例程式碼&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;View Customer&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;a th:href=&quot;@&#123;/&#125;&quot;&gt;Home&lt;/a&gt;&lt;/div&gt;&lt;h1&gt;View Customer&lt;/h1&gt;&lt;div th:object=&quot;$&#123;customer&#125;&quot;&gt;    &lt;p&gt;&lt;strong&gt;First Name:&lt;/strong&gt; &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;    &lt;p&gt;&lt;strong&gt;Last Name:&lt;/strong&gt; &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;    &lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; &lt;span th:text=&quot;*&#123;email&#125;&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n測試操作流程\n進入首頁：前往 http://localhost:8080/ 查看現有客戶資料（若無客戶則為空列表）。\n新增客戶：\n點擊 **”Add New Customer”**。\n嘗試送出空白表單，觀察錯誤提示。\n填寫錯誤格式的 Email，再次送出檢查提示。\n正確填寫資料後提交，應能看到新客戶出現在首頁列表中。\n\n\n檢視單一客戶：點擊 “View” 以查看詳細資訊。\n修改客戶資料：點擊 “Edit” 修改資料並提交，確認首頁資料已更新。\n刪除客戶：點擊 **”Delete”**，確認資料已成功刪除。\n\n\n程式碼下載點此下載完整專案程式碼\n\n透過上述說明，可以清楚理解如何使用 Thymeleaf 完成一個基本的客戶管理系統，涵蓋客戶資料的新增、修改、檢視及刪除操作。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","MongoDB","Thymeleaf"]},{"title":"Spring Boot project-oriented programming（11）會員註冊與登入系統：專案設定","url":"/2024/10/20/spring-boot-pop-11/","content":"為什麼不使用 csrf().disable()因為此方法已經過時，未來將不再支援。在本教學中，我們會採用符合 6.1 版規範的新寫法。\n舊有的寫法儘管程式能正常運作，但會顯示紅線警告：csrf() 自 6.1 版後已棄用，並計劃移除。\n\n\n改進後的寫法新寫法不會出現紅線警告，僅顯示黃線，表示還有進一步最佳化的空間。\n\n為什麼不最佳化：我認為對於新手來說，使用 cors → cors.disable() 這類寫法比較簡單，且更易於應用到其他情境。例如：\n若要設定 .authorizeHttpRequests，可以類推出：\n.authorizeHttpRequests(authorize -&gt; authorize.一些設定)\n\nSpring Security 的教學將在 第 13 篇繼續。\n\n專案介紹：會員註冊與登入系統此專案將建置一個 會員註冊登入系統，使用者可透過網頁註冊與登入。我們會透過 Spring Security 驗證會員的 Email 與密碼，只有輸入正確的帳密才能登入。此外，未登入時無法進入某些特定頁面。\n專案目標：與以往不同，此專案不會一次提供完整的 Controller、Service、Repository。我希望將 Spring Security 的教學分步拆解，以簡化理解難度，循序漸進。\n\n專案架構User Entity\n\n\n欄位名稱\n資料類型\n說明\n\n\n\nid\nLong\n唯一識別碼\n\n\nemail\nString\n電子郵件\n\n\npassword\nString\n密碼\n\n\n系統功能\n\n\n路徑\nHTTP 方法\n功能描述\n\n\n\n&#x2F;\nGET\n顯示首頁\n\n\n&#x2F;register\nGET\n註冊頁面\n\n\n&#x2F;register\nPOST\n新增使用者\n\n\n&#x2F;users\nGET\n顯示用戶的 Email 列表\n\n\n&#x2F;login\nGET\n登入頁面\n\n\n&#x2F;login\nPOST\n處理登入程序\n\n\n&#x2F;logout\nGET\n登出\n\n\n\n建立專案按照以下說明建立專案，下載並解壓縮範例檔案。\n\n\n創立資料庫並進行連接\n開啟 **MySQL Client (MariaDB (x64))**。\n輸入密碼並按下 Enter。\n執行以下指令建立資料庫：\n\nCREATE DATABASE user_db;\n\n\n關閉視窗，開啟專案並修改 **application.properties**：\n\nspring.application.name=user_registration_systemspring.datasource.url=jdbc:mariadb://localhost:3306/user_dbspring.datasource.username=rootspring.datasource.password=填入密碼spring.datasource.driver-class-name=org.mariadb.jdbc.Driverspring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=true\n\n啟動專案，確認資料庫是否能成功連接。如果沒有錯誤訊息即表示成功。\n\nEntity：User在這裡建立 User Entity，並設置資料表名稱為 users：\n@Entity@Table(name = &quot;users&quot;)public class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    @Column(unique = true, nullable = false)    @NotEmpty(message = &quot;email為必填項目&quot;)    @Email(message = &quot;請填入正確的Email&quot;)    private String email;    @Column(nullable = false)    @NotEmpty(message = &quot;密碼為必填項目&quot;)    private String password;    public User() &#123;&#125;    public User(Long id, String email, String password) &#123;        this.id = id;        this.email = email;        this.password = password;    &#125;    public Long getId() &#123;        return id;    &#125;    public void setId(Long id) &#123;        this.id = id;    &#125;    public String getEmail() &#123;        return email;    &#125;    public void setEmail(String email) &#123;        this.email = email;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;&#125;\n\n啟動專案後，檢查資料表是否成功建立。\n\nRepository：UserRepositorypublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125;\n\n\n建立 AuthController 與首頁AuthController 將負責完成註冊與登入功能。專案完成後，未登入者只能存取 AuthController 的內容，無法進入其他頁面。\nAuthController 基本結構：\n@Controllerpublic class AuthController &#123;    // 顯示首頁    @GetMapping(&quot;/&quot;)    public String index() &#123;        return &quot;index&quot;;    &#125;&#125;\n\n首頁模板：index.html\n此頁面目前僅提供前往首頁與註冊頁面的按鈕（點擊註冊頁面會顯示 404，因尚未建立）。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;User Registration System&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;a th:href=&quot;@&#123;/&#125;&quot;&gt;Home&lt;/a&gt;        &lt;a th:href=&quot;@&#123;/register&#125;&quot;&gt;Register&lt;/a&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n啟動專案並進入 http://localhost:8080/ ，確認是否能看到首頁上的 Home 與 Register 按鈕。\n\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","Spring Security"]},{"title":"Spring Boot project-oriented programming（12）會員註冊與登入系統：註冊","url":"/2024/10/21/spring-boot-pop-12/","content":"完成註冊頁面新增註冊頁面首先，我們在 AuthController.java 中新增一個方法，用來處理顯示註冊頁面：\n// 顯示註冊頁面@GetMapping(&quot;/register&quot;)public String register(Model model) &#123;    User user = new User();    model.addAttribute(&quot;user&quot;, user);    return &quot;register&quot;;&#125;\n\n透過此設定，我們可以成功進入註冊頁面。\n建立 register.html 模板接著，我們新增 register.html 來呈現註冊表單。如果使用者已經註冊，表單內提供切換至登入頁面的連結：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;User Registration System&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;div&gt;            &lt;a th:href=&quot;@&#123;/&#125;&quot;&gt;Home&lt;/a&gt;            &lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;Login&lt;/a&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;form method=&quot;post&quot; th:action=&quot;@&#123;/register&#125;&quot; th:object=&quot;$&#123;user&#125;&quot;&gt;                &lt;div&gt;                    &lt;label&gt;User Email&lt;/label&gt;                    &lt;input type=&quot;text&quot; placeholder=&quot;Enter user email&quot; th:field=&quot;*&#123;email&#125;&quot; /&gt;                    &lt;p th:if=&quot;$&#123;#fields.hasErrors(&#x27;email&#x27;)&#125;&quot; th:errors=&quot;*&#123;email&#125;&quot;&gt;&lt;/p&gt;                &lt;/div&gt;                &lt;div&gt;                    &lt;label&gt;User Password&lt;/label&gt;                    &lt;input type=&quot;password&quot; placeholder=&quot;Enter user password&quot; th:field=&quot;*&#123;password&#125;&quot; /&gt;                    &lt;p th:if=&quot;$&#123;#fields.hasErrors(&#x27;password&#x27;)&#125;&quot; th:errors=&quot;*&#123;password&#125;&quot;&gt;&lt;/p&gt;                &lt;/div&gt;                &lt;button type=&quot;submit&quot;&gt;Register&lt;/button&gt;                &lt;span&gt;Already registered? &lt;a th:href=&quot;@&#123;/login&#125;&quot;&gt;Login&lt;/a&gt;&lt;/span&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n啟動專案後，即可順利進入註冊頁面。然而目前註冊功能尚未實作。  \n\n完成註冊功能在 AuthController.java 中新增處理註冊請求的邏輯首先，我們透過建構子注入 UserService，負責處理使用者的業務邏輯：\nprivate final UserService userService;public AuthController(UserService userService) &#123;    this.userService = userService;&#125;\n\n新增註冊功能：\n@PostMapping(&quot;/register&quot;)public String saveUser(Model model,                        @Valid @ModelAttribute(&quot;user&quot;) User user,                        BindingResult bindingResult) &#123;    if (bindingResult.hasErrors()) &#123;        model.addAttribute(&quot;user&quot;, user);        return &quot;register&quot;;    &#125;    userService.createUser(user);    return &quot;redirect:/&quot;;&#125;\n\n此段程式碼會在後端驗證表單資料，若通過驗證，便將使用者資料存入資料庫。\n建立 UserService 以儲存使用者資料@Servicepublic class UserService &#123;    private final UserRepository userRepository;    public UserService(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;    public void createUser(User user) &#123;        userRepository.save(user);    &#125;&#125;\n\n註冊完成後，我們可以使用 MySQL 客戶端驗證資料是否成功儲存：\nUSE user_db;SELECT * FROM users;\n\n當成功註冊後，輸入的使用者資料會顯示於資料庫中。  \n\n防止重複註冊並顯示錯誤訊息若用戶嘗試使用相同的 Email 註冊，會出現 500 錯誤，因為資料庫中的 Email 欄位設定了 unique = true。我們需要在前端顯示錯誤訊息，而非直接返回 500 錯誤。\n更新 UserRepository在 UserRepository.java 中新增透過 Email 查詢用戶的方法：\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;    User findUserByEmail(String email);&#125;\n\n在 UserService 中新增查詢方法public User getUserByEmail(String email) &#123;    return userRepository.findUserByEmail(email);&#125;\n\n在 AuthController 中處理重複註冊的狀況我們修改 saveUser 方法來檢查 Email 是否已被註冊：\n@PostMapping(&quot;/register&quot;)public String saveUser(Model model,                        @Valid @ModelAttribute(&quot;user&quot;) User user,                        BindingResult bindingResult) &#123;    User existingUser = userService.getUserByEmail(user.getEmail());    if (existingUser != null) &#123;        bindingResult.rejectValue(&quot;email&quot;, null, &quot;Email 已註冊&quot;);        model.addAttribute(&quot;user&quot;, user);        return &quot;register&quot;;    &#125;    if (bindingResult.hasErrors()) &#123;        return &quot;register&quot;;    &#125;    userService.createUser(user);    return &quot;redirect:/&quot;;&#125;\n\n現在，如果使用者輸入重複的 Email，會在註冊表單上顯示錯誤訊息，而不是拋出 500 錯誤。\n\n團隊協作中的驗證責任分工在專案中，前後端都應該負責資料驗證。若缺乏協作，容易出現以下情況：  \n\n前端認為資料驗證應由後端處理，而直接將資料傳送。\n後端認為前端應該已完成基本的驗證，導致未進一步檢查。\n\n這種情況常引發爭執，因此最佳實踐是前後端雙方都進行驗證，或在專案初期就明確協商好責任分工，以確保系統的穩定性與使用者體驗。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","Spring Security"]},{"title":"Spring Boot project-oriented programming（14）會員註冊與登入系統：登出和自訂驗證系統","url":"/2024/10/23/spring-boot-pop-14/","content":"登出設定在 AppConfig.java 的 formLogin 後面加入以下程式碼，將登出的網址設定為 /logout，並且登出後會轉址至 /login?logout。\n.logout(logout -&gt; logout                        .logoutUrl(&quot;/logout&quot;)                        .logoutSuccessUrl(&quot;/login?logout&quot;))\n\n修改 users.html，加入登出按鈕：\n...&lt;a th:href=&quot;@&#123;/&#125;&quot;&gt;Home&lt;/a&gt;&lt;a th:href=&quot;@&#123;/logout&#125;&quot;&gt;Logout&lt;/a&gt;...\n\n在 login.html 中新增登出的訊息，並增加在登入錯誤時顯示錯誤訊息的功能：\n\n當網址為 login?logout，代表已登出，顯示 You&#39;ve logged out.\n當網址為 login?error，代表 email 或密碼錯誤，顯示 Wrong email or password.\n\n...&lt;h3 th:if=&quot;$&#123;param.logout&#125;&quot;&gt;You&#x27;ve logged out.&lt;/h3&gt;&lt;h3 th:if=&quot;$&#123;param.error&#125;&quot;&gt;Wrong email or password&lt;/h3&gt;&lt;form method=&quot;post&quot; role=&quot;form&quot; th:action=&quot;@&#123;/login&#125;&quot;&gt;...\n\n啟動專案後，嘗試登出，檢查登出後的訊息是否正確顯示。輸入錯誤的密碼進行登入，可以觀察到錯誤提示訊息。\n\n明文儲存密碼的問題查看資料庫中的內容時，我們可以看到用戶的 id、email 及密碼。有些小型網站會將密碼以明文方式儲存，用戶忘記密碼時可直接將原密碼發送給他。\n這種做法有嚴重的安全問題：如果資料庫被駭客入侵，駭客可以輕易取得用戶的明文密碼，並在其他網站上測試，增加用戶其他帳號被盜用的風險。\n為了避免這種情況，我們應該採用雜湊的方式來儲存密碼。\n\n雜湊密碼在 Spring Security 中啟用雜湊函式。在 AppConfig.java 中新增以下程式碼：\n@Beanpublic PasswordEncoder passwordEncoder()&#123;    return new BCryptPasswordEncoder();&#125;\n\n在 UserService.java 中將密碼進行雜湊後再儲存至資料庫：\npublic void createUser(User user) &#123;    user.setPassword(passwordEncoder.encode(user.getPassword()));    userRepository.save(user);&#125;\n\n這樣可以確保用戶的密碼能安全地儲存。\n\n自訂登入驗證系統建立 CustomUserDetailsServiceImpl.java，用來驗證用戶的 email 和密碼。\n// CustomUserDetailsServiceImpl.java@Servicepublic class CustomUserDetailsServiceImpl implements UserDetailsService &#123;    private final UserRepository userRepository;    public CustomUserDetailsServiceImpl(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;    @Override    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException &#123;        User user = userRepository.findUserByEmail(email);        if (user == null) &#123;            throw new UsernameNotFoundException(&quot;User not found with email :&quot; + email);        &#125;        List&lt;GrantedAuthority&gt; authorities = List.of(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;));        return new org.springframework.security.core.userdetails.User(user.getEmail(), user.getPassword(), authorities);    &#125;&#125;\n\n刪除資料庫中未經雜湊的舊資料，使用 MySQL Client (MariaDB (x64)) 查詢未雜湊的密碼：\nUSE user_db;SELECT * FROM users WHERE password NOT LIKE &quot;$%&quot;;\n\n雜湊後的密碼是以 $ 開頭，查詢非 $ 開頭的資料並顯示在螢幕上。確認無誤後，刪除舊資料：\nDELETE FROM users WHERE password NOT LIKE &quot;$%&quot;;\n\n啟動專案，註冊新用戶並登入，確認新的登入驗證系統正常運作。\n專案已經完成。\n\n程式碼需自行編寫 application.properties 設定檔。詳細程式碼下載：連結 。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","Spring Security"]},{"title":"Spring Boot project-oriented programming（15） 從零開始打造電商購物車系統：專案結構與資料庫連接詳解","url":"/2024/10/24/spring-boot-pop-15/","content":"如果你正在尋找如何完成一個電商專案，恭喜你來對地方了！\n本專案是一個 RESTful API 專案，非常適合搭配前端框架，我們將使用 Vue.js 作為前端，讓專案進化成一個前後端分離的架構。\n我們的優點\n有完整教學\n照著做就能完成資料庫設定，不需加入其他群組。\n可以直接下載程式碼（Day22 會提供連結）\n完全免費\n串接支付平台（使用 Stripe）\nRedis 快取功能\nRabbitMQ 消息隊列\n支援高併發\n\n我們的缺點\n小型專案，適合學習但不適合商業化\n沒有整合 Swagger\n\n成果展示（需搭配 Vue.js 部分）\n\n\n\nEntity 格式和專案功能User\n\n\n欄位名稱\n資料型態\n說明\n\n\n\nid\nString\n唯一的 id\n\n\nemail\nString\n電子郵件\n\n\npassword\nString\n密碼\n\n\nProduct\n\n\n欄位名稱\n資料型態\n說明\n\n\n\nid\nLong\n唯一的 id\n\n\nname\nString\n商品名稱\n\n\ndescription\nString\n商品描述\n\n\nprice\nInteger\n價格\n\n\nimage\nString\n商品圖片存放的網址\n\n\ncategory\nString\n商品的類別\n\n\nCart\n\n\n欄位名稱\n資料型態\n說明\n\n\n\nid\nLong\n唯一的 id\n\n\nuser\nUser\n關聯到用戶，用來將購物車與用戶的資訊連接\n\n\ncartItems\nSet\n購物車內的商品\n\n\ntotalPrice\nInteger\n購物車內的商品的總價格\n\n\ntotalQuantity\nInteger\n購物車內的商品數量\n\n\nCartItem\n\n\n欄位名稱\n資料型態\n說明\n\n\n\nid\nLong\n唯一的 id\n\n\ncart\nCart\n關聯到購物車，將 Cart 與 CartItem 的資訊連接\n\n\nproduct\nProduct\n關聯到商品，將 Product 與 CartItem 的資訊連接\n\n\nprice\nInteger\n商品的價格\n\n\nquantity\nInteger\n商品的數量\n\n\nOrder\n\n\n欄位名稱\n資料型態\n說明\n\n\n\nid\nLong\n唯一的 id\n\n\nsessionId\nString\nStripe API 的 Session ID\n\n\namount\nInteger\nStripe 顯示的結帳金額\n\n\nurl\nString\nStripe 的支付連結\n\n\nuserId\nLong\n紀錄訂單所屬用戶\n\n\n功能\n\n\n路徑\nHTTP 請求方法\n說明\nRequest body\nRequest header\n\n\n\n&#x2F;auth&#x2F;signup\nPOST\n註冊\nUser\n無\n\n\n&#x2F;auth&#x2F;login\nPOST\n登入\nUser\n無\n\n\n&#x2F;api&#x2F;user&#x2F;\nGET\n取得目前登入的用戶資訊\n無\nJWT\n\n\n&#x2F;api&#x2F;product&#x2F;\nPOST\n建立商品\nProduct\nJWT\n\n\n&#x2F;api&#x2F;product&#x2F;{id}\nDELETE\n刪除商品\n無\nJWT\n\n\n&#x2F;api&#x2F;product&#x2F;{id}\nGET\n取得商品\n無\nJWT\n\n\n&#x2F;api&#x2F;product&#x2F;?minPrice&#x3D;&amp;maxPrice&#x3D;&amp;category&#x3D;&amp;sort&#x3D;&amp;pageNumber&#x3D;&amp;pageSize&#x3D;\nGET\n根據條件篩選並分頁商品\n無\nJWT\n\n\n&#x2F;api&#x2F;cart&#x2F;\nGET\n取得購物車的內容\n無\nJWT\n\n\n&#x2F;api&#x2F;cart&#x2F;add\nPUT\n將商品加入購物車\nAddItemRequest\nJWT\n\n\n&#x2F;api&#x2F;cartItem&#x2F;{cartItemId}\nPUT\n修改購物車內的商品數量\nCartItem\nJWT\n\n\n&#x2F;api&#x2F;cartItem&#x2F;{cartItemId}\nDELETE\n刪除購物車內的商品\n無\nJWT\n\n\n&#x2F;api&#x2F;order&#x2F;create_session\nGET\n建立 Stripe 支付 Session\n無\nJWT\n\n\n&#x2F;api&#x2F;order&#x2F;find_order\nGET\n找尋該用戶的所有訂單\n無\nJWT\n\n\n專案建立完成安裝設定後，下載並解壓縮專案。\n\n連接資料庫打開 MySQL Client（使用 MariaDB），輸入以下指令建立資料庫：\nCREATE DATABASE cart_db;\n\n在 application.properties 中添加：\nspring.datasource.url=jdbc:mariadb://localhost:3306/cart_dbspring.datasource.username=rootspring.datasource.password=密碼spring.datasource.driver-class-name=org.mariadb.jdbc.Driverspring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=true\n\n啟動專案確認連接狀況。\n不過，將密碼直接寫在 application.properties 中有安全風險，在使用 Git 時，可能會不小心將密碼洩露到 GitHub。舉例來說，可以在 GitHub 上搜尋 datasource.password，會發現有些人的密碼被洩露了。\n\n建議在專案根目錄（與 pom.xml 同層）建立 .env（無副檔名）檔案，並寫入密碼：\nDATASOURCE_PASSWORD=密碼\n\n接著改寫 application.properties 的部分配置：\nspring.config.import=file:.env[.properties]spring.datasource.url=jdbc:mariadb://localhost:3306/cart_dbspring.datasource.username=root\n\n最後對應 .env 中的內容，讀取 DATASOURCE_PASSWORD：\nspring.datasource.password=$&#123;DATASOURCE_PASSWORD&#125;\n\n確認專案是否正常連接資料庫。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API"]},{"title":"Spring Boot project-oriented programming（13）會員註冊與登入系統：登入、Spring Security設定","url":"/2024/10/22/spring-boot-pop-13/","content":"顯示註冊用戶接下來我們將實作一個顯示所有用戶 email 的頁面，這個頁面將會被設定為只有登入的用戶才可查看。\n在這之前，我們可以先參考過去專案的實現方式來實作。\n以下是顯示用戶列表的程式碼：\n// UserService.javapublic List&lt;User&gt; getAllUsers() &#123;    return userRepository.findAll();&#125;\n\n// AuthController.java// 顯示所有用戶 email 的網頁@GetMapping(&quot;/users&quot;)public String users(Model model) &#123;    List&lt;User&gt; users = userService.getAllUsers();    model.addAttribute(&quot;users&quot;, users);    return &quot;users&quot;;&#125;\n\n前端頁面顯示用戶列表：\n&lt;!-- users.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;User Registration System&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;a th:href=&quot;@&#123;/&#125;&quot;&gt;Home&lt;/a&gt;    &lt;h1&gt;List of Users&lt;/h1&gt;    &lt;table&gt;        &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;User ID&lt;/th&gt;            &lt;th&gt;User Email&lt;/th&gt;        &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;        &lt;tr th:each=&quot;user : $&#123;users&#125;&quot;&gt;            &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt;            &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;/tbody&gt;    &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n啟動專案並前往 http://localhost:8080/users ，你將可以看到所有註冊用戶的 email。\n目前這個頁面尚未進行登入和權限的驗證，因此任何人都能夠看到機密的用戶資料。我們應當進行登入功能的開發，以保護這些敏感資訊。\n開發登入功能首先，在 AuthController.java 中新增顯示登入頁面的功能：\n// 顯示登入頁面@GetMapping(&quot;/login&quot;)public String login(Model model) &#123;    return &quot;login&quot;;&#125;\n\n並設計登入頁面的 HTML：\n&lt;!-- login.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;User Registration System&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;    &lt;a th:href=&quot;@&#123;/&#125;&quot;&gt;Home&lt;/a&gt;    &lt;a th:href=&quot;@&#123;/register&#125;&quot;&gt;Register&lt;/a&gt;    &lt;form method=&quot;post&quot; th:action=&quot;@&#123;/login&#125;&quot;&gt;        &lt;div&gt;            &lt;label&gt;User Email&lt;/label&gt;            &lt;input type=&quot;text&quot; id=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Enter user email&quot;/&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;label&gt;User Password&lt;/label&gt;            &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Enter user password&quot;/&gt;        &lt;/div&gt;        &lt;button type=&quot;submit&quot;&gt;Login&lt;/button&gt;        &lt;span&gt;Not registered? &lt;a th:href=&quot;@&#123;/register&#125;&quot;&gt;Register&lt;/a&gt;&lt;/span&gt;    &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\nCSRF（跨站請求偽造）跨站請求偽造（CSRF）是網路攻擊的一種常見方式，攻擊者透過偽造請求來操作使用者的行為。為防止 CSRF 攻擊，我們應採取一些保護措施，例如：\n\n使用 CSRF Token 驗證請求。\n檢查 HTTP header 中的 Referer 欄位，以確保請求來源是合法的。\n避免使用 GET 方法來執行重要操作，改用 POST 方法。\n\nSpring Security 設定接下來，我們將使用 Spring Security 來設定權限管理。首先，在 src/main/java/com/user_registration_system/user_registration_system/Config 資料夾中新增 AppConfig.java 文件。\n// AppConfig.java@Configurationpublic class AppConfig &#123;    @Bean    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception &#123;        http.csrf(csrf -&gt; csrf.disable())  // 關閉 CSRF 防護            .authorizeHttpRequests(authorizeRequests -&gt; authorizeRequests                .requestMatchers(&quot;/users/**&quot;).authenticated()  // /users/** 需要登入                .anyRequest().permitAll()  // 其他路徑允許匿名存取            )            .formLogin(form -&gt; form                .loginPage(&quot;/login&quot;)  // 自訂登入頁面                .usernameParameter(&quot;email&quot;)  // 使用 email 作為登入欄位                .passwordParameter(&quot;password&quot;)  // 密碼欄位設定                .loginProcessingUrl(&quot;/login&quot;)  // 處理登入請求                .defaultSuccessUrl(&quot;/users&quot;, true)  // 登入成功後導向 /users 頁面            )            .httpBasic(Customizer.withDefaults());  // 使用預設的 HTTP Basic 驗證        return http.build();    &#125;&#125;\n\n在這裡，我們使用 Spring Security 的預設驗證機制。在啟動專案後：\n\n嘗試進入 http://localhost:8080/users ，會被自動轉址到 http://localhost:8080/login 。\n使用 Spring Security 預設提供的用戶名 user 和專案啟動時顯示的臨時密碼登入。\n\n如需自定用戶名和密碼，可以在 application.properties 中設定：\nspring.security.user.name=userspring.security.user.password=pw\n\n完成後，你就可以使用固定的用戶名和密碼進行登入了。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","Spring Security"]},{"title":"Spring Boot project-oriented programming（16） 從零開始打造電商購物車系統：Spring Security設定","url":"/2024/10/25/spring-boot-pop-16/","content":"Spring Security 設定在進行註冊與登入功能之前，我們需要先設定 Spring Security。\n在之前的專案中，我們曾提到 CSRF（跨站請求偽造）的問題，但當時並未真正處理。這次，我們將引入 JSON Web Token（JWT） 來解決 CSRF 攻擊的問題。\nJWT 是一種用來驗證使用者身份的方式，若能夠成功驗證有效的 JWT，便可確定操作來自合法使用者。這有點像古代的「尚方寶劍」，擁有尚方寶劍的人便有行使權力的資格，即使壞人拿到也能為所欲為。因此，妥善保護 JWT 的安全非常重要。\n接下來，我們將新增 SecurityConfig.java，與之前相同，透過 SecurityFilterChain 來設定 Spring Security。\n@Configurationpublic class SecurityConfig &#123;    @Bean    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception &#123;\n\n無狀態 Session 設定將 session 設定為無狀態（Stateless），這表示後端不會再使用或儲存 session。前端需自行保存所需的資料，並在每次請求時傳送必要的資訊（如 Token）給後端，代表保持登入的功能完全由前端管理。\n若前端未傳送 Token 至後端，則後端將視為未登入狀態，不論之前是否有登入過。這樣的設計能降低後端伺服器的負擔，避免因 session 儲存過多而占滿硬碟空間，以及降低 session 讀取時的 CPU 使用率。\nhttpSecurity.sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n\n設定 API 權限以 /api 開頭的 API 端點需要驗證權限，其餘端點則無須驗證，允許所有請求。\n.authorizeHttpRequests(authorizeHttpRequests -&gt; authorizeHttpRequests.requestMatchers(&quot;/api/**&quot;).authenticated().anyRequest().permitAll())\n\n以下網址無須驗證，可直接訪問：\n\nhttp://localhost:8080/hello/ ✔️\nhttp://localhost:8080/test/ ✔️\n\n以下網址需通過驗證：\n\nhttp://localhost:8080/api/ ⚠️\nhttp://localhost:8080/api/hello ⚠️\n\n關閉 CSRF 保護我們將關閉 Spring Security 的 CSRF 防護，因為之後會使用 JWT 來防範 CSRF 攻擊。\n.csrf(csrf -&gt; csrf.disable())\n\nCORS 設定雖然這個 Spring Boot 專案只實現後端部分，但若將來需要讓前端訪問後端，可能會遇到 CORS（跨來源資源共享）相關的錯誤。後端可以預先配置 CORS 設定，便於前端與後端的通訊。以下設定僅供參考，不必加入到 SecurityConfig 中。\n.cors(cors -&gt; cors.configurationSource(new CorsConfigurationSource() &#123;                    @Override                    public CorsConfiguration getCorsConfiguration(HttpServletRequest request) &#123;                        CorsConfiguration config = new CorsConfiguration();\n\n允許的前端網址來源：\nconfig.setAllowedOrigins(Arrays.asList(                                &quot;前端的網址，例如 http://localhost:5173&quot;                        ));\n\n允許的 HTTP 請求方法：\nconfig.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;));                        config.setAllowCredentials(true);\n\n設定允許 JWT 通過的 HTTP 標頭：\n第一層過濾 HTTP 標頭：\nconfig.setExposedHeaders(Arrays.asList(&quot;Authorization&quot;));\n\n第二層過濾 HTTP 標頭：\nconfig.setAllowedHeaders(Arrays.asList(&quot;Authorization&quot;, &quot;Content-Type&quot;));\n\n設置過濾有效時間，3600 秒內不會重複檢查同樣的請求：\n        config.setMaxAge(3600L);        return config;    &#125;&#125;));\n\n設定密碼雜湊演算法使用 BCrypt 作為密碼雜湊函式，可調整雜湊的強度，例如將值從 10 提高到更大的數字，以增加安全性，但同時會耗費更多計算資源來雜湊密碼。\n@Bean    public PasswordEncoder passwordEncoder() &#123;        return new BCryptPasswordEncoder(10);    &#125;\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","Spring Security"]},{"title":"Spring Boot project-oriented programming（19） 從零開始打造電商購物車系統：JWT驗證和Spring Security","url":"/2024/10/28/spring-boot-pop-19/","content":"在這份教學中，我們專注於實作JWT認證，以通過Spring Security的驗證流程，並保護API不受未授權的瀏覽。以下是如何整合JWT進行驗證的步驟詳解。\n\n添加JWT Filter首先，修改 SecurityConfig.java，在 csrf 設定的下一行添加以下內容，使Spring Security優先處理JWT認證：\n.addFilterBefore(new JWTAuthenticationFilter(), BasicAuthenticationFilter.class)\n\n這段程式碼將JWT認證的filter加到基本權限驗證filter之前。\n攔截JWT進行驗證接著，在 Config 目錄下建立 JWTAuthenticationFilter.java，該類會攔截帶有 Authorization header 的請求。\n確保 Authentication 依賴選擇 org.springframework 的版本，避免使用到 apache 的錯誤導入。\npublic class JWTAuthenticationFilter extends OncePerRequestFilter &#123;    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;        String jwt = request.getHeader(&quot;Authorization&quot;);        if(jwt != null)&#123;            jwt = jwt.substring(&quot;Bearer &quot;.length() - 1);            try &#123;                SecretKey key = Keys.hmacShaKeyFor(JWTConstant.SECRET != null ? JWTConstant.SECRET.getBytes() : null);                Claims claims = Jwts.parserBuilder()                                    .setSigningKey(key)                                    .build()                                    .parseClaimsJws(jwt)                                    .getBody();                String email = String.valueOf(claims.get(&quot;email&quot;));                Authentication authentication = new UsernamePasswordAuthenticationToken(email, null, null);                SecurityContextHolder.getContext().setAuthentication(authentication);            &#125; catch (Exception e) &#123;                throw new BadCredentialsException(&quot;Invalid JWT or expired&quot;);            &#125;        &#125;        filterChain.doFilter(request, response);    &#125;&#125;\n\n使用JWT取得授權建立 UserController.java 以實現受JWT保護的用戶資料讀取。若沒有JWT，則不允許瀏覽用戶資訊：\n@RestController@RequestMapping(&quot;/api/user&quot;)public class UserController &#123;    private final UserService userService;    public UserController(UserService userService) &#123;        this.userService = userService;    &#125;    @GetMapping(&quot;/&quot;)    public ResponseEntity&lt;User&gt; getUserInfo(@RequestHeader(&quot;Authorization&quot;) String jwt) throws Exception &#123;        User user = userService.findUserByJWT(jwt);        return new ResponseEntity&lt;&gt;(user, HttpStatus.OK);    &#125;&#125;\n\n在 UserService.java 中，添加 findUserByJWT 方法來依據JWT中的email尋找用戶：\nprivate final JWTProvider jwtProvider;public UserService(/*skip*/, JWTProvider jwtProvider) &#123;    //skip    this.jwtProvider = jwtProvider;&#125;public User findUserByJWT(String jwt) throws Exception&#123;    String email = jwtProvider.getEmailFromJWT(jwt);    User user = userRepository.findByEmail(email);    if(user == null)&#123;        throw new Exception(&quot;Error: Invalid JWT&quot;);    &#125;    return user;&#125;\n\n在 JWTProvider.java 中，添加取得email的程式碼：\npublic String getEmailFromJWT(String jwt) &#123;    jwt = jwt.substring(&quot;Bearer &quot;.length() - 1);    Claims claims = Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(jwt).getBody();    return String.valueOf(claims.get(&quot;email&quot;));&#125;\n\n測試\n登入取得JWT。\n使用JWT作為 Bearer Token 發送GET請求到 http://localhost:8080/api/user/。\n若JWT無效或過期，將返回錯誤程式碼403。\n\n注意事項JWT的安全性非常重要，因為只要獲得JWT便可取得用戶資訊。這就是為什麼在使用JWT時必須妥善保護token，避免因洩露導致安全風險。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","Spring Security","JWT"]},{"title":"Spring Boot project-oriented programming（17） 從零開始打造電商購物車系統：JWT設定","url":"/2024/10/26/spring-boot-pop-17/","content":"導入JWT由於我們需要使用JWT（JSON Web Token），但在Spring Initializr中無法直接選擇jjwt，因此我們需要手動在pom.xml中加入相應的依賴。在&lt;dependencies&gt;的下一行添加以下內容：\n&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;    &lt;version&gt;0.11.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;    &lt;version&gt;0.11.5&lt;/version&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;    &lt;version&gt;0.11.5&lt;/version&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\n\n在IDE右上角會出現「Load Maven Changes」的按鈕，點擊它，或按下Ctrl+Shift+O來更新依賴變更。\n\n接著，在Config資料夾內建立JWTConstant.java來存放加密用的常數。可以自行設定這個常數，只要是32個以上的英文或數字組成的字串即可，即使是一個隨機的字串也能當作SECRET。\npublic class JWTConstant &#123;    public static final String SECRET = &quot;Aeqt7zELDZnUSpy9Qr5mRNWdT3bK2ahF&quot;;&#125;\n\n使用 .env 文件載入 JWT_CONSTANT如果將JWT_CONSTANT直接寫在專案中可能會有安全風險，因此我們將改為從.env文件中載入。首先，需在pom.xml中加入相應的依賴。\n&lt;dependency&gt;    &lt;groupId&gt;io.github.cdimascio&lt;/groupId&gt;    &lt;artifactId&gt;java-dotenv&lt;/artifactId&gt;    &lt;version&gt;5.2.2&lt;/version&gt;&lt;/dependency&gt;\n\n在專案的根目錄創建 .env 文件，並加入以下內容：\nJWT_CONSTANT=Aeqt7zELDZnUSpy9Qr5mRNWdT3bK2ahF\n\n修改JWTConstant.java以從.env讀取JWT_CONSTANT：\npublic class JWTConstant &#123;    static Dotenv dotenv = Dotenv.load();    public static final String SECRET = dotenv.get(&quot;JWT_CONSTANT&quot;);&#125;\n\n這樣就可以從.env文件中讀取JWT_CONSTANT。\n設定JWT的產生在Config資料夾中建立JWTProvider.java，用來產生JWT。\n利用JWTConstant的SECRET來產生驗證用的密鑰，預設採用HMAC-SHA256加密，因此選擇產生HMAC-SHA256格式的密鑰。\n@Servicepublic class JWTProvider &#123;    SecretKey key = Keys.hmacShaKeyFor(JWTConstant.SECRET != null ? JWTConstant.SECRET.getBytes() : null);\n\n設定產生的JWT中包含的內容，如token的發行時間、過期時間等。\n這裡設定12小時後到期，超過此時間的token將無法通過驗證。\n使用密鑰簽章可用來驗證內容有無被修改，並將格式轉換成String。\n    public String generateToken()&#123;        return Jwts.builder()                .setIssuedAt(new Date())                .setExpiration(new Date(new Date().getTime() + 12 * 60 * 60 * 1000))                .signWith(key)                .compact();    &#125;&#125;\n\n獲取JWT設置好JWT後，接下來要從後端取得它。我們可以先構建一個註冊的框架，新增AuthController.java。\n目前設定是當讀取網頁時即可獲得JWT。\n@RestController@RequestMapping(&quot;/auth&quot;)public class AuthController &#123;    private final JWTProvider jwtProvider;    public AuthController(JWTProvider jwtProvider) &#123;        this.jwtProvider = jwtProvider;    &#125;    @PostMapping(&quot;/signup&quot;)    public ResponseEntity&lt;AuthResponse&gt; createUserHandler()&#123;        // 使用JWTProvider產生token        String token = jwtProvider.generateToken();        AuthResponse authResponse = new AuthResponse();        authResponse.setJwt(token);        authResponse.setMessage(&quot;Signup Success&quot;);        return new ResponseEntity&lt;&gt;(authResponse, HttpStatus.CREATED);    &#125;&#125;\n\n由於ResponseEntity只能返回單一內容或文本，如果想要一次傳送多個內容，需要新增一個類別，並將所需內容包裝進去。Response/AuthResponse.java的內容如下：\npublic class AuthResponse &#123;    private String jwt;    private String message;    public AuthResponse()&#123;    &#125;    public AuthResponse(String jwt, String message) &#123;        this.jwt = jwt;        this.message = message;    &#125;    public String getJwt() &#123;        return jwt;    &#125;    public void setJwt(String jwt) &#123;        this.jwt = jwt;    &#125;    public String getMessage() &#123;        return message;    &#125;    public void setMessage(String message) &#123;        this.message = message;    &#125;&#125;\n\n這樣我們就可以在傳送JWT的同時，也送出「Signup Success」的訊息。\n測試在這裡提供一個用來測試專案的設定檔案，供下載：\n下載測試檔案\n使用API測試工具，發送POST請求到http://localhost:8080/auth/signup ，即可獲得jwt和「Signup Success」的訊息。\n\n如果在前一章節不小心設置了CORS，那麼可能會顯示「Invalid CORS request」，請註解掉CORS的部分。\n驗證JWT將JWT複製，貼到 jwt.io 進行驗證。\n在「VERIFY SIGNATURE」部分輸入自己的JWT_CONSTANT，當看到「signature verified」表示JWT的內容未遭篡改。\n\nJWT由三個部分組成：header、payload、signature。\n\nHeader：存放加密方式和token的格式，如JWT。\nPayload：包含發行和到期的相關內容，也可以用來夾帶一些自定義信息，如email用於識別。\nSignature：用來確認JWT有無被修改。\n\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","JWT"]},{"title":"Spring Boot project-oriented programming（20） 從零開始打造電商購物車系統：商品管理的基本功能","url":"/2024/10/29/spring-boot-pop-20/","content":"在購物車系統中，商品管理是不可或缺的一部分。本教學將指導您如何建立 Product 實體、ProductRepository、ProductService 和 ProductController，並完成新增、刪除及查詢商品的 API 功能。\n建立 Product 實體類別首先，建立 Product.java 來代表商品的基本資料。\n@Entity@Table(name = &quot;products&quot;)public class Product &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String name;    private String description;    private Integer price;    private String image;    private String category;    public Product() &#123;&#125;    public Product(Long id, String name, String description, Integer price, String image, String category) &#123;        this.id = id;        this.name = name;        this.description = description;        this.price = price;        this.image = image;        this.category = category;    &#125;    // Getter 和 Setter&#125;\n\n建立 ProductRepository接下來，創建 ProductRepository 來定義與資料庫的基本操作。\npublic interface ProductRepository extends JpaRepository&lt;Product, Long&gt; &#123;&#125;\n\n建立 ProductServiceProductService 處理商品的業務邏輯，包括新增、刪除及依 ID 查詢商品。\n@Servicepublic class ProductService &#123;    private final ProductRepository productRepository;    public ProductService(ProductRepository productRepository) &#123;        this.productRepository = productRepository;    &#125;    public Product addProduct(Product product) &#123;        return productRepository.save(product);    &#125;    public String deleteProduct(Long id)&#123;        productRepository.deleteById(id);        return &quot;Product deleted successfully&quot;;    &#125;    public Product getProductById(Long id) throws Exception &#123;        return productRepository.findById(id)                .orElseThrow(() -&gt; new Exception(&quot;Product not found&quot;));    &#125;&#125;\n\n建立 ProductController最後，在 ProductController 中定義新增、刪除、查詢商品的 API。\n@RestController@RequestMapping(&quot;/api/product&quot;)public class ProductController &#123;    private final ProductService productService;    public ProductController(ProductService productService) &#123;        this.productService = productService;    &#125;    @PostMapping(&quot;/&quot;)    public ResponseEntity&lt;Product&gt; addProduct(@RequestBody Product product) &#123;        Product createdProduct = productService.addProduct(product);        return new ResponseEntity&lt;&gt;(createdProduct, HttpStatus.CREATED);    &#125;    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;String&gt; deleteProduct(@PathVariable(&quot;id&quot;) Long id) &#123;        return new ResponseEntity&lt;&gt;(productService.deleteProduct(id), HttpStatus.OK);    &#125;    @GetMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;Product&gt; getProductById(@PathVariable(&quot;id&quot;) Long id) throws Exception &#123;        return new ResponseEntity&lt;&gt;(productService.getProductById(id), HttpStatus.OK);    &#125;&#125;\n\n測試功能以下為測試商品管理功能的步驟：\n\n新增商品\n\n使用 POST 請求至 http://localhost:8080/api/product/ ，在請求的 body 中新增商品資料。\n\n\n查詢商品\n\n使用 GET 請求至 http://localhost:8080/api/product/&#123;id&#125; 查詢指定 ID 的商品。\n\n\n刪除商品\n\n使用 DELETE 請求至 http://localhost:8080/api/product/&#123;id&#125; 刪除指定 ID 的商品。\n\n\n\n商品篩選與分頁功能進一步擴充 Controller，實現商品篩選（類別、價格範圍）和分頁功能。\n// ProductController.java@GetMapping(&quot;/&quot;)public ResponseEntity&lt;Page&lt;Product&gt;&gt; findProductByFilter(        @RequestParam(value = &quot;category&quot;, required = false) String category,        @RequestParam(value = &quot;minPrice&quot;, required = false) Integer minPrice,        @RequestParam(value = &quot;maxPrice&quot;, required = false) Integer maxPrice,        @RequestParam(value = &quot;sort&quot;, required = false) String sort,        @RequestParam(value = &quot;pageNumber&quot;, required = true) Integer pageNumber,        @RequestParam(value = &quot;pageSize&quot;, required = true) Integer pageSize) &#123;        Page&lt;Product&gt; filteredProductsPage = productService.getProductsByFilter(category, minPrice, maxPrice, sort, pageNumber, pageSize);    return new ResponseEntity&lt;&gt;(filteredProductsPage, HttpStatus.OK);&#125;\n\nService 層的篩選與分頁實現在 ProductService 中加入篩選邏輯。\npublic Page&lt;Product&gt; getProductsByFilter(String category, Integer minPrice, Integer maxPrice, String sort, Integer pageNumber, Integer pageSize) &#123;    Pageable pageable = PageRequest.of(pageNumber, pageSize);    List&lt;Product&gt; products = productRepository.findProductsByFilter(category, minPrice, maxPrice, sort);    int startIndex = (int) pageable.getOffset();    int endIndex = Math.min((startIndex + pageable.getPageSize()), products.size());    List&lt;Product&gt; pageContent = products.subList(startIndex, endIndex);    return new PageImpl&lt;&gt;(pageContent, pageable, products.size());&#125;\n\nRepository 層的自訂查詢在 ProductRepository 中定義自訂 SQL 查詢以篩選商品。\n@Query(&quot;SELECT p FROM Product p &quot; +       &quot;WHERE (p.category = :category OR :category LIKE &#x27;&#x27;) &quot; +       &quot;AND (:minPrice IS NULL OR p.price &gt;= :minPrice) &quot; +       &quot;AND (:maxPrice IS NULL OR p.price &lt;= :maxPrice) &quot; +       &quot;ORDER BY CASE :sort WHEN &#x27;price_low&#x27; THEN p.price END ASC, &quot; +       &quot;CASE :sort WHEN &#x27;price_high&#x27; THEN p.price END DESC&quot;)public List&lt;Product&gt; findProductsByFilter(@Param(&quot;category&quot;) String category,                                          @Param(&quot;minPrice&quot;) Integer minPrice,                                          @Param(&quot;maxPrice&quot;) Integer maxPrice,                                          @Param(&quot;sort&quot;) String sort);\n\n一次新增多筆商品將 ProductController 更新為支持批次新增商品功能。\n@PostMapping(&quot;/&quot;)public ResponseEntity&lt;List&lt;Product&gt;&gt; addProducts(@RequestBody Product[] products) &#123;    List&lt;Product&gt; createdProducts = new ArrayList&lt;&gt;();    for(Product product : products) &#123;        Product p = productService.addProduct(product);        createdProducts.add(p);    &#125;    return new ResponseEntity&lt;&gt;(createdProducts, HttpStatus.CREATED);&#125;\n\n測試篩選與分頁\n分頁查詢: http://localhost:8080/api/product/?pageNumber=0&amp;pageSize=5\n按價格篩選: http://localhost:8080/api/product/?minPrice=100&amp;maxPrice=200\n篩選類別: http://localhost:8080/api/product/?category=Bags\n價格排序: http://localhost:8080/api/product/?sort=price_low\n\n至此，我們已完成商品的基本 CRUD 操作以及篩選、分頁功能！\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API"]},{"title":"Spring Boot project-oriented programming（22） 從零開始打造電商購物車系統：串接Stripe API支付與使用SSL","url":"/2024/10/31/spring-boot-pop-22/","content":"Stripe 註冊Stripe 是一個支持多國貨幣且 API 文件齊全的支付平台，對於不需要註冊公司即可使用的 Stripe，非常適合新創項目和個人使用。註冊 Stripe 時，請選擇「美國」。\n\n資料庫實體 (Entity)我們的資料庫中會有一張 orders 資料表。以下是 Order 實體類別的範例：\n@Entity@Table(name = &quot;orders&quot;)public class Order &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String sessionId;    private Integer amount;    private String status;    @Column(length = 1024)    private String url; // 設定這個欄位上限為1024字元，以儲存較長的 URL    private Long userId;    // Constructors, Getters, and Setters...&#125;\n\n\n資料庫存取層 (Repository)實作一個 OrderRepository 來進行 Order 的查詢和儲存。這裡我們會用一個方法 findOrderByUserId 來查詢特定用戶的訂單資料：\npublic interface OrderRepository extends JpaRepository&lt;Order, Long&gt; &#123;    @Query(&quot;SELECT o FROM Order o WHERE o.userId = :userId&quot;)    public List&lt;Order&gt; findOrderByUserId(@Param(&quot;userId&quot;) Long userId);&#125;\n\n\nStripe API 金鑰設定取得 API 金鑰登入 Stripe 後，前往 API 金鑰頁面 。複製測試環境的 sk_test 開頭的金鑰，並將它放入 .env 檔案：\nSTRIPE_PRIVATE_KEY=sk_test_xxxxxx\n\n加入 Stripe SDK在 pom.xml 中添加 Stripe SDK：\n&lt;dependency&gt;  &lt;groupId&gt;com.stripe&lt;/groupId&gt;  &lt;artifactId&gt;stripe-java&lt;/artifactId&gt;  &lt;version&gt;26.7.0&lt;/version&gt;&lt;/dependency&gt;\n\n\nService 層我們從 .env 檔案中讀取 Stripe 私鑰，並設定到 OrderService 中來使用 Stripe API。\n// OrderService.java@Servicepublic class OrderService &#123;    private final OrderRepository orderRepository;    public OrderService(OrderRepository orderRepository) &#123;        this.orderRepository = orderRepository;        Dotenv dotenv = Dotenv.load();        Stripe.apiKey = dotenv.get(&quot;STRIPE_PRIVATE_KEY&quot;);    &#125;    public Session createCheckoutSession(int amount) throws StripeException &#123;        SessionCreateParams params = SessionCreateParams.builder()            .setMode(SessionCreateParams.Mode.PAYMENT)            .setSuccessUrl(&quot;http://localhost:5173/checkout/success&quot;)            .addLineItem(SessionCreateParams.LineItem.builder()                .setQuantity(1L)                .setPriceData(SessionCreateParams.LineItem.PriceData.builder()                    .setCurrency(&quot;twd&quot;)                    .setUnitAmount(amount * 100L) // 金額單位為分                    .setProductData(SessionCreateParams.LineItem.PriceData.ProductData.builder()                        .setName(&quot;購物車商品&quot;)                        .build())                    .build())                .build())            .build();        return Session.create(params);    &#125;    public Order createOrder(String sessionId, Integer totalPrice, String status, String url, Long userId) throws Exception &#123;        Order order = new Order();        order.setSessionId(sessionId);        order.setAmount(totalPrice);        order.setStatus(status);        order.setUrl(url);        order.setUserId(userId);        return orderRepository.save(order);    &#125;    public List&lt;Order&gt; findOrderByUserId(Long userId) throws Exception &#123;        List&lt;Order&gt; orders = orderRepository.findOrderByUserId(userId);        for(Order order : orders)&#123;            updateOrder(order.getId());        &#125;        return orders;    &#125;    public void updateOrder(Long id) throws Exception &#123;        Optional&lt;Order&gt; opt = orderRepository.findById(id);        if(opt.isPresent()) &#123;            Order updated = opt.get();            Session session = Session.retrieve(opt.get().getSessionId());            updated.setStatus(session.getPaymentStatus());            orderRepository.save(updated);        &#125; else &#123;            throw new Exception(&quot;Error: Order not found with id: &quot; + id);        &#125;    &#125;&#125;\n\n\nController 層設定 OrderController，當前端請求產生支付 session 時建立訂單：\n@RestController@RequestMapping(&quot;/api/order&quot;)public class OrderController &#123;    private final OrderService orderService;    private final UserService userService;    private final CartService cartService;    public OrderController(OrderService orderService, UserService userService, CartService cartService)&#123;        this.orderService = orderService;        this.userService = userService;        this.cartService = cartService;    &#125;    @GetMapping(&quot;/create_session&quot;)    public ResponseEntity&lt;Order&gt; createCheckoutSession(@RequestHeader(&quot;Authorization&quot;) String jwt) throws Exception &#123;        User user = userService.findUserByJWT(jwt);        Long userId = user.getId();        Integer totalPrice = cartService.clearCart(userId);        Session session = orderService.createCheckoutSession(totalPrice);        Order order = orderService.createOrder(session.getId(), totalPrice, session.getPaymentStatus(), session.getUrl(), userId);        return new ResponseEntity&lt;&gt;(order, HttpStatus.OK);    &#125;    @GetMapping(&quot;/find_order&quot;)    public ResponseEntity&lt;List&lt;Order&gt;&gt; findOrderByUserId(@RequestHeader(&quot;Authorization&quot;) String jwt) throws Exception &#123;        User user = userService.findUserByJWT(jwt);        return ResponseEntity.ok(orderService.findOrderByUserId(user.getId()));    &#125;&#125;\n\n\n測試\n在購物車中添加商品並產生支付 session。\n前往產生的 URL 進行測試付款，測試卡號使用 4242 4242 4242 4242。\n\n付款成功後，檢查訂單狀態是否從 unpaid 更新為 paid。\n\n（可選）導入 SSL使用 OpenSSL 自簽證書來加密應用程序傳輸的數據：\n\n使用 OpenSSL 產生私鑰：\nopenssl genrsa -out private.key 2048\n\n創建 openssl.conf，設定基本證書參數：\n[req]prompt = nodistinguished_name = dn[dn]C = TWST = TaiwanL = TaipeiO = Shopping Cart Inc.OU = Software DevelopmentCN = localhost\n\n使用 OpenSSL 產生證書：\nopenssl req -new -x509 -key private.key -out certificate.crt -days 365 -config openssl.conf\n\n將私鑰和證書打包為 .p12 文件：\nopenssl pkcs12 -export -out certificate.p12 -inkey private.key -in certificate.crt\n\n修改 application.properties 來啟用 SSL：\nserver.ssl.enabled=trueserver.ssl.key-store=classpath:certificate.p12server.ssl.key-store-password=secretserver.ssl.key-store-type=PKCS12\n\n通過此步驟，我們的專案可通過 HTTPS 安全瀏覽，防止資料被竊取。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","Stripe"]},{"title":"Spring Boot project-oriented programming（18） 從零開始打造電商購物車系統：開發登入、註冊功能","url":"/2024/10/27/spring-boot-pop-18/","content":"註冊功能開發流程建立 User 實體類別在註冊功能開發中，首先我們需要建立 User 實體類別，對應資料庫的 users 資料表。\n@Entity@Table(name = &quot;users&quot;)public class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String email;    private String password;    public User() &#123;&#125;    public User(Long id, String email, String password) &#123;        this.id = id;        this.email = email;        this.password = password;    &#125;    public Long getId() &#123; return id; &#125;    public void setId(Long id) &#123; this.id = id; &#125;    public String getEmail() &#123; return email; &#125;    public void setEmail(String email) &#123; this.email = email; &#125;    public String getPassword() &#123; return password; &#125;    public void setPassword(String password) &#123; this.password = password; &#125;&#125;\n\n建立 UserRepository接下來，我們需要建立 UserRepository，並繼承 JpaRepository 使用 JPA 的基本操作。同時，我們在此添加依照 email 查詢的自定義方法。\npublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;    User findByEmail(String email);&#125;\n\n實作 UserService在 UserService 中，我們新增使用者時會先檢查 email 是否已註冊，若已存在則拋出例外，提示使用者已註冊。\n@Servicepublic class UserService &#123;    private final UserRepository userRepository;    private final PasswordEncoder passwordEncoder;    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) &#123;        this.userRepository = userRepository;        this.passwordEncoder = passwordEncoder;    &#125;    public void createUser(User user) throws Exception &#123;        User isEmailExists = userRepository.findByEmail(user.getEmail());        if (isEmailExists != null) &#123;            throw new Exception(&quot;Error: Email is already registered.&quot;);        &#125;        User createdUser = new User();        createdUser.setEmail(user.getEmail());        createdUser.setPassword(passwordEncoder.encode(user.getPassword()));        userRepository.save(createdUser);    &#125;&#125;\n\n建立 AuthController 的註冊端點在 AuthController 中新增註冊端點，從請求中取得 email 和 password，呼叫 UserService 創建新用戶，成功後生成 JWT 並返回註冊成功訊息。\n@PostMapping(&quot;/signup&quot;)public ResponseEntity&lt;AuthResponse&gt; createUserHandler(@RequestBody User user) throws Exception &#123;    userService.createUser(user);    String token = jwtProvider.generateToken(user.getEmail());    AuthResponse authResponse = new AuthResponse();    authResponse.setJwt(token);    authResponse.setMessage(&quot;Signup Success&quot;);    return new ResponseEntity&lt;&gt;(authResponse, HttpStatus.CREATED);&#125;\n\n測試註冊功能啟動專案後，測試註冊功能，設定 email 和 password。成功後會得到包含 JWT 的註冊成功訊息，並可檢查資料庫中是否有新增的用戶資訊。\n&#123;    &quot;email&quot;: &quot;user@new.com&quot;,    &quot;password&quot;: &quot;12345678&quot;&#125;\n\n\n增加 JWT 中的 Email 欄位在產生 JWT 時，我們可以在 payload 中夾帶 email 以辨別 token 所屬的用戶。\n修改 AuthController 端點，傳遞 Email 給 JWTProviderString token = jwtProvider.generateToken(user.getEmail());\n\n修改 JWTProvider，加入 Email 欄位於 JWT 的 claim 中加入 email，方便解讀。\npublic String generateToken(String email) &#123;    return Jwts.builder()            .setIssuedAt(new Date())            .setExpiration(new Date(new Date().getTime() + 12 * 60 * 60 * 1000))            .claim(&quot;email&quot;, email)            .signWith(key)            .compact();&#125;\n\n這樣，當我們將 token 貼到 jwt.io 時，即可在 payload 中看到 email 欄位。\n\n登入功能開發完成註冊後，我們開始實作登入功能。若驗證成功，將返回包含 JWT 的登入成功訊息。\n登入端點的實作根據提供的 email 尋找用戶，若無法找到或密碼不正確，將拋出例外。\n此過程中不直接顯示錯誤細節以避免暴露email資訊。\n@PostMapping(&quot;/login&quot;)public ResponseEntity&lt;AuthResponse&gt; loginHandler(@RequestBody User user) throws Exception &#123;    User foundUser = userService.findUserByEmail(user.getEmail());    if (foundUser == null || !passwordEncoder.matches(user.getPassword(), foundUser.getPassword())) &#123;        throw new Exception(&quot;Invalid email or password&quot;);    &#125;    String token = jwtProvider.generateToken(foundUser.getEmail());    AuthResponse authResponse = new AuthResponse();    authResponse.setJwt(token);    authResponse.setMessage(&quot;Login Success&quot;);        return new ResponseEntity&lt;&gt;(authResponse, HttpStatus.OK);&#125;\n\n修改 UserService，增加查詢用戶的方法在 UserService 中添加根據 email 查詢用戶的方法。\npublic User findUserByEmail(String email) &#123;    return userRepository.findByEmail(email);&#125;\n\n測試登入功能使用註冊過的 email 和 password 進行登入，成功後可獲得包含 JWT 的登入成功訊息。\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","JWT"]},{"title":"Spring Boot project-oriented programming（23） 從零開始打造電商購物車系統：導入Redis、RabbitMQ、Docker","url":"/2024/11/01/spring-boot-pop-23/","content":"Redis：提升資料讀取性能的關鍵為何選擇 Redis在專案中，如果遇到高頻讀取的資料庫查詢，資料庫讀取速度可能會成為效能瓶頸。為解決此問題，我們使用 Redis 將常用資料快取於記憶體 (RAM) 中，讓系統能直接從 Redis 讀取資料，從而減少資料庫 (MariaDB) 存取次數，有效降低延遲並增強高併發能力。\n什麼是 RedisRedis 是一款 NoSQL 資料庫，以 key-value 格式儲存資料，並將其存於 RAM 中，這使得 Redis 具有極高的讀寫速度，非常適合快取和即時存取需求。\n安裝與啟動 RedisRedis 僅支援 Unix 和 Linux 系統，Windows 用戶可透過 Docker 安裝並執行 Redis：\n安裝步驟：\n安裝 Docker，下載網址：Docker 官網 。\n安裝後啟動 Docker。\n開啟終端機或命令提示字元，執行下載指令：  docker pull redis:latest\n使用以下指令啟動 Redis 容器：  docker run --name my-redis -d redis\n\n至此，您已安裝並啟用 Redis，可在專案中使用 Redis 進行快取。\n\n專案配置 Redis 快取添加依賴在 pom.xml 中引入 Redis 所需的依賴包：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置 Redis 連線於 application.properties 中設定 Redis 的主機與連結埠：\nspring.data.redis.port=6379spring.data.redis.host=localhost\n\nRedis 快取配置建立 Config/RedisConfig.java，設定 Redis 快取所需的序列化器和快取管理：\n@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(factory);        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.WRAPPER_ARRAY);        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(objectMapper, Object.class);                redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setValueSerializer(serializer);        redisTemplate.afterPropertiesSet();        return redisTemplate;    &#125;    @Bean    public RedisCacheManager redisCacheManager(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123;        RedisCacheWriter writer = RedisCacheWriter.nonLockingRedisCacheWriter(redisTemplate.getConnectionFactory());        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisTemplate.getValueSerializer()));        return new RedisCacheManager(writer, config);    &#125;&#125;\n\n\n資料快取管理UserService 快取應用在 Service/UserService.java 中快取用戶資料，若快取命中則直接返回，否則讀取資料庫並存入快取，並設置隨機過期時間 (30-39 分鐘) 以避免集體失效：\n@Servicepublic class UserService &#123;    private final RedisTemplate&lt;String, Object&gt; redisTemplate;    private static final int USER_CACHE_MINUTES = 30;    public UserService(UserRepository userRepository, RedisTemplate&lt;String, Object&gt; redisTemplate) &#123;        this.redisTemplate = redisTemplate;    &#125;    public User findUserByEmail(String email) &#123;        String cacheKey = &quot;user:email:&quot; + email;        User cachedUser = (User) redisTemplate.opsForValue().get(cacheKey);        if (cachedUser != null) &#123;            return cachedUser;        &#125;        User user = userRepository.findByEmail(email);        if (user != null) &#123;            redisTemplate.opsForValue().set(cacheKey, user, USER_CACHE_MINUTES + new Random().nextInt(10), TimeUnit.MINUTES);        &#125;        return user;    &#125;&#125;\n\nProductService 快取應用在 Service/ProductService.java 中，產品資料快取並處理刪除操作：\n@Servicepublic class ProductService &#123;    private final RedisTemplate&lt;String, Object&gt; redisTemplate;    private static final int PRODUCT_CACHE_MINUTES = 5;    public ProductService(ProductRepository productRepository, RedisTemplate&lt;String, Object&gt; redisTemplate) &#123;        this.redisTemplate = redisTemplate;    &#125;    public String deleteProduct(Long id) &#123;        productRepository.deleteById(id);        redisTemplate.delete(&quot;product:&quot; + id);        return &quot;Product deleted successfully&quot;;    &#125;    public Product getProductById(Long id) throws Exception &#123;        String cacheKey = &quot;product:&quot; + id;        Product cachedProduct = (Product) redisTemplate.opsForValue().get(cacheKey);        if (cachedProduct != null) &#123;            return cachedProduct;        &#125;        Optional&lt;Product&gt; productOpt = productRepository.findById(id);        if (productOpt.isPresent()) &#123;            Product product = productOpt.get();            redisTemplate.opsForValue().set(cacheKey, product, PRODUCT_CACHE_MINUTES + new Random().nextInt(3), TimeUnit.MINUTES);            return product;        &#125;        throw new Exception(&quot;Product not found&quot;);    &#125;&#125;\n\n\nRabbitMQ 使用指南什麼是 RabbitMQRabbitMQ 是一個訊息代理，負責將訊息傳遞到 Queue（訊息佇列），並依設定將其轉發給消費者（Consumers）。可透過不同類型的 Exchanges（交換器）靈活的路由訊息到指定 Queue。\n為什麼使用 RabbitMQ耗時操作會影響系統回應速度，例如在用戶註冊後發送 Email。若無 RabbitMQ，需等待 Email 發送完才能繼續操作，影響體驗。加入 RabbitMQ 後，這類操作可轉移至 Queue 中，由消費者非同步處理，避免系統阻塞，用戶可立即繼續操作。\nRabbitMQ 安裝推薦使用 Docker 安裝：\ndocker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:4-management\n\n專案導入 Email 和 RabbitMQ在 pom.xml 中加入 Mail 和 AMQP 依賴：\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;\n\n設定 application.propertiesspring.mail.host=smtp.gmail.comspring.mail.port=587spring.mail.username=$&#123;GMAIL_ADDRESS&#125;spring.mail.password=$&#123;GMAIL_PASSWORD&#125;spring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.rabbitmq.host=localhostspring.rabbitmq.port=5672spring.rabbitmq.username=guestspring.rabbitmq.password=guest\n\n取得應用程式密碼：至 Google 帳戶 -&gt; 安全性 -&gt; 開啟兩步驟驗證 -&gt; 應用程式密碼。\n將密碼設定 .env 中的 GMAIL_PASSWORD。\nRabbitMQ 配置建立 RabbitMQConfig.java，配置 Queue 和 Exchange：\n@Configurationpublic class RabbitMQConfig &#123;    public static final String QUEUE_NAME = &quot;emailQueue&quot;;    public static final String EXCHANGE_NAME = &quot;emailExchange&quot;;    @Bean    public Queue queue() &#123;        return new Queue(QUEUE_NAME, true);    &#125;    @Bean    public TopicExchange exchange() &#123;        return new TopicExchange(EXCHANGE_NAME);    &#125;    @Bean    public Binding binding(Queue queue, TopicExchange exchange) &#123;        return BindingBuilder.bind(queue).to(exchange).with(&quot;email.routing.key&quot;);    &#125;&#125;\n\n建立消費者 EmailConsumer在 EmailConsumer.java 中設置消費者接收 Queue 訊息：\n@Componentpublic class EmailConsumer &#123;    private final EmailService emailService;    public EmailConsumer(EmailService emailService) &#123;        this.emailService = emailService;    &#125;    @RabbitListener(queues = RabbitMQConfig.QUEUE_NAME)    public void receiveMessage(String to) &#123;        emailService.sendSimpleEmail(to);    &#125;&#125;\n\n發送 Email在 EmailService.java 中實現發送 Email 功能：\n@Servicepublic class EmailService &#123;    private final JavaMailSender javaMailSender;    public EmailService(JavaMailSender javaMailSender) &#123;        this.javaMailSender = javaMailSender;    &#125;    public void sendSimpleEmail(String to) &#123;        Dotenv dotenv = Dotenv.load();        SimpleMailMessage message = new SimpleMailMessage();        message.setTo(to);        message.setSubject(&quot;Welcome to Shopping Cart, &quot; + to + &quot; !&quot;);        message.setText(&quot;Thank you for choosing Shopping Cart. We look forward to serving you and making your shopping experience enjoyable.\\n&quot; +                        &quot;Best regards,\\n&quot; +                        &quot;The Shopping Cart Team&quot;);        message.setFrom(dotenv.get(&quot;GMAIL_ADDRESS&quot;));        javaMailSender.send(message);    &#125;&#125;\n\n在 UserService 中使用 RabbitMQ 發送 Email在 UserService.java 中註冊成功時，將 Email 發送請求傳送到對應的 Queue：\n@Servicepublic class UserService &#123;    private final RabbitTemplate rabbitTemplate;    public UserService(RabbitTemplate rabbitTemplate) &#123;        this.rabbitTemplate = rabbitTemplate;    &#125;    public void createUser(User user) throws Exception &#123;        if (userRepository.findByEmail(user.getEmail()) != null) &#123;            throw new Exception(&quot;Error: Email is already registered.&quot;);        &#125;        User createdUser = new User();        createdUser.setEmail(user.getEmail());        createdUser.setPassword(passwordEncoder.encode(user.getPassword()));        sendEmail(user.getEmail());        userRepository.save(createdUser);    &#125;    public void sendEmail(String to) &#123;        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME, &quot;email.routing.key&quot;, to);    &#125;&#125;\n\n使用 RabbitMQ 後，系統反應更即時。\n\nDocker 一鍵部署專案安裝 MariaDB、Redis 和 RabbitMQ 有時會讓人感到繁瑣。現在，我們可以使用 Docker 將所有環境設定、編譯和啟動自動化，讓專案的部署只需一行命令。\n只需準備好專案原始碼和 .env 檔案，在專案根目錄添加 docker-compose.yml 和 Dockerfile，即可自動完成部署。\ndocker-compose.yml首先編寫 docker-compose.yml，用於配置 MariaDB、Redis、RabbitMQ 的環境。\nservices:  db:    image: mariadb:latest    container_name: mariadb_cart    restart: always    environment:      MARIADB_ROOT_PASSWORD: 12345678      MARIADB_DATABASE: cart_db    ports:      - &quot;3306:3306&quot;    volumes:      - db_data:/var/lib/mysql  redis:    image: redis:latest    container_name: redis_cart    restart: always    ports:      - &quot;6379:6379&quot;  rabbitmq:    image: rabbitmq:4-management    container_name: rabbitmq_cart    restart: always    ports:      - &quot;5672:5672&quot;      - &quot;15672:15672&quot;    environment:      RABBITMQ_DEFAULT_USER: guest      RABBITMQ_DEFAULT_PASS: guest    volumes:      - rabbitmq_data:/var/lib/rabbitmq  app:    build: .    container_name: java_cart    restart: always    ports:      - &quot;8080:8080&quot;    environment:      SPRING_DATASOURCE_URL: jdbc:mariadb://db:3306/cart_db      SPRING_DATASOURCE_USERNAME: root      SPRING_DATASOURCE_PASSWORD: 12345678      SPRING_DATA_REDIS_HOST: redis      SPRING_RABBITMQ_HOST: rabbitmqvolumes:  db_data:  rabbitmq_data:\n\nDockerfile接著，編寫 Dockerfile，設定自動編譯並執行 Spring Boot 應用程式。\nFROM maven:3-amazoncorretto-17 AS buildCOPY . /appWORKDIR /appRUN mvn clean package -DskipTestsFROM amazoncorretto:17-alpineCOPY --from=build /app/target/*.jar app.jarCOPY ./.env .envEXPOSE 8080ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]\n\n使用以下指令即可啟動環境並部署專案：\ndocker-compose up\n\n\nJMeter 壓力測試使用 JMeter 進行高併發專案的性能測試。\n設定了 1000 並發數量，執行四種請求（Get Product By Filter、Get User Cart、Add To Cart、Find Order），重複三次，共計 12,000 個請求，對專案的處理能力是極大挑戰。\n\n測試結果顯示，最高延遲為 2845 毫秒。這在如此高壓下依然不錯，且達到 100% 成功率，沒有任何錯誤。\n\n最低延遲僅 5 毫秒，表現出色。\n\n高併發專案成功通過壓力測試，證明其在 17 秒內承受 12,000 個請求的高併發處理能力。\n完整程式碼可以前往觀看\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","Stripe","Redis","RabbitMQ"]},{"title":"Spring Boot project-oriented programming（21） 從零開始打造電商購物車系統：打造購物車","url":"/2024/10/30/spring-boot-pop-21/","content":"EntityCart (購物車)首先，建立 Cart 實體類別，該類別包含購物車的基本屬性，例如ID、所屬用戶、購物清單、總價格及購買數量等。\n@Entitypublic class Cart &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    @OneToOne    @JoinColumn(name = &quot;user_id&quot;, nullable = false)    private User user;    @OneToMany(mappedBy = &quot;cart&quot;, cascade = CascadeType.ALL, orphanRemoval = true)    private Set&lt;CartItem&gt; cartItems = new HashSet&lt;&gt;();    private Integer totalPrice;    private Integer totalQuantity;    // constructors, getters, and setters&#125;\n\n註解解釋\n@OneToOne: 表示Cart和User之間是一對一的關聯關係。\n\n@JoinColumn(name = &quot;user_id&quot;, nullable = false): 在Cart表格中新增user_id欄位，且不允許空值。\n\n@OneToMany(mappedBy = &quot;cart&quot;, cascade = CascadeType.ALL, orphanRemoval = true): 表示Cart和CartItem是一對多的關聯關係。\n\ncascade = CascadeType.ALL: 對Cart的所有操作都會傳播至其所包含的CartItem。\norphanRemoval = true: 當Cart中移除某個CartItem，該項商品在資料庫中也會被刪除。\n\n\n\nCartItem (購物車商品項)CartItem 類別用於表示購物車中的每一項商品，包含ID、所屬購物車、商品、價格、數量等屬性。\n@Entitypublic class CartItem &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    @ManyToOne    @JsonIgnore    private Cart cart;    @ManyToOne    private Product product;    private Integer price;    private Integer quantity;    // constructors, getters, and setters&#125;\n\n註解解釋\n@ManyToOne: 多對一的關係。\n@JsonIgnore: 在 JSON 輸出中隱藏此屬性，避免循環引用。\n\nRepositoryCartRepository 和 CartItemRepository 為操作購物車數據的介面，並提供特定方法供業務邏輯使用。\nCartRepositorypublic interface CartRepository extends JpaRepository&lt;Cart, Long&gt; &#123;    @Query(&quot;SELECT c FROM Cart c WHERE c.user.id = :userId&quot;)    public Cart findCartByUserId(@Param(&quot;userId&quot;) Long userId);&#125;\n\nCartItemRepositorypublic interface CartItemRepository extends JpaRepository&lt;CartItem, Long&gt; &#123;    @Query(&quot;SELECT ci FROM CartItem ci WHERE ci.cart = :cart AND ci.product = :product&quot;)    public CartItem isCartItemInCart(@Param(&quot;cart&quot;) Cart cart, @Param(&quot;product&quot;) Product product);&#125;\n\nServiceCartServiceCartService 提供購物車的各種操作，包括建立、添加商品、計算總價、清空等功能。\n\n建立購物車\n\npublic Cart createCart(User user) &#123;    Cart cart = new Cart();    cart.setUser(user);    return cartRepository.save(cart);&#125;\n\n\n將商品加入購物車\n\npublic void addToCart(Long userId, AddItemRequest req) throws Exception &#123;    Cart cart = cartRepository.findCartByUserId(userId);    Product product = productService.getProductById(req.getProductId());    CartItem isPresent = cartItemService.isCartItemInCart(cart, product);    if (isPresent == null) &#123;        CartItem cartItem = new CartItem();        cartItem.setCart(cart);        cartItem.setProduct(product);        cartItem.setQuantity(req.getQuantity());        cartItem.setPrice(req.getQuantity() * product.getPrice());        CartItem createdCartItem = cartItemService.createCartItem(cartItem);        cart.getCartItems().add(createdCartItem);        calcCartTotal(userId);    &#125;&#125;\n\n\n計算購物車的總價和總數量\n\npublic Cart calcCartTotal(Long userId) &#123;    Cart cart = cartRepository.findCartByUserId(userId);    int totalPrice = 0, totalQuantity = 0;    for (CartItem cartItem : cart.getCartItems()) &#123;        totalPrice += cartItem.getPrice();        totalQuantity += cartItem.getQuantity();    &#125;    cart.setTotalPrice(totalPrice);    cart.setTotalQuantity(totalQuantity);    return cartRepository.save(cart);&#125;\n\n\n清空購物車\n\npublic Integer clearCart(Long userId) throws Exception &#123;    Cart cart = cartRepository.findCartByUserId(userId);    Integer totalPrice = cart.getTotalPrice();    Iterator&lt;CartItem&gt; iterator = cart.getCartItems().iterator();    while (iterator.hasNext()) &#123;        CartItem cartItem = iterator.next();        cartItemService.removeCartItem(userId, cartItem.getId());        iterator.remove();    &#125;    cart.setTotalPrice(0);    cart.setTotalQuantity(0);    cartRepository.save(cart);    return totalPrice;&#125;\n\nCartItemServiceCartItemService 用於處理購物車項的相關操作。\n\n檢查商品是否在購物車中\n\npublic CartItem isCartItemInCart(Cart cart, Product product) &#123;    return cartItemRepository.isCartItemInCart(cart, product);&#125;\n\n\n新增或更新 CartItem\n\npublic CartItem createCartItem(CartItem cartItem) &#123;    cartItem.setQuantity(Math.max(cartItem.getQuantity(), 1));    cartItem.setPrice(cartItem.getProduct().getPrice() * cartItem.getQuantity());    return cartItemRepository.save(cartItem);&#125;\n\nControllerCartController\n獲取購物車內容\n\n@GetMapping(&quot;/&quot;)public ResponseEntity&lt;Cart&gt; findUserCart(@RequestHeader(&quot;Authorization&quot;) String jwt) throws Exception &#123;    User user = userService.findUserByJWT(jwt);    Cart cart = cartService.calcCartTotal(user.getId());    return new ResponseEntity&lt;&gt;(cart, HttpStatus.OK);&#125;\n\n\n添加商品至購物車\n\n@PutMapping(&quot;/add&quot;)public ResponseEntity&lt;String&gt; addItemToCart(@RequestBody AddItemRequest req, @RequestHeader(&quot;Authorization&quot;) String jwt) throws Exception &#123;    User user = userService.findUserByJWT(jwt);    cartService.addToCart(user.getId(), req);    return new ResponseEntity&lt;&gt;(&quot;Item added to cart&quot;, HttpStatus.OK);&#125;\n\nCartItemController\n修改購物車中的商品數量\n\n@PutMapping(&quot;/&#123;cartItemId&#125;&quot;)public ResponseEntity&lt;String&gt; updateCartItem(@PathVariable(&quot;cartItemId&quot;) Long id,                                             @RequestBody CartItem cartItem,                                             @RequestHeader(&quot;Authorization&quot;) String jwt) throws Exception &#123;    User user = userService.findUserByJWT(jwt);    cartItemService.updateCartItem(user.getId(), id, cartItem);    return new ResponseEntity&lt;&gt;(&quot;Cart item updated successfully&quot;, HttpStatus.OK);&#125;\n\n\n刪除購物車商品\n\n@DeleteMapping(&quot;/&#123;cartItemId&#125;&quot;)public ResponseEntity&lt;String&gt; deleteCartItem(@PathVariable(&quot;cartItemId&quot;) Long id,                                             @RequestHeader(&quot;Authorization&quot;) String jwt) throws Exception &#123;    User user = userService.findUserByJWT(jwt);    cartItemService.removeCartItem(user.getId(), id);    return new ResponseEntity&lt;&gt;(&quot;CartItem deleted successfully&quot;, HttpStatus.OK);&#125;","categories":["Java"],"tags":["Java","Spring Boot","RESTful API"]},{"title":"Spring Boot project-oriented programming（24）在Spring Boot導入Ollama完成AI","url":"/2024/11/02/spring-boot-pop-24/","content":"這個專案將使用 Ollama 來實現基礎的 AI 功能。由於我們採用的是簡易模型，效能可能不如 ChatGPT 或 Copilot，偶爾出現不合適的回答是正常現象。本專案的主要目的是讓大家學習如何在 Spring 中整合 AI。\n\n今天，我們要開始一個 AI 專案，使用已經訓練好的模型。\nAI 的發展猶如軍備競賽，不僅需要大量的資金購買 GPU，也需要投入大量時間訓練模型。對於我們普通人來說，從零開始打造自己的 AI 語言模型相當困難，但可以借助企業訓練好的模型來實現 AI 應用。\n\n在這個專案中，我們將透過 Ollama 來實現 AI 聊天和圖片內容辨識功能。\n最初，我曾考慮過 ChatGPT，但因其 API 需付費，我認為這對初學者可能不夠友善，因此選擇了免費的 Ollama。使用 Ollama 需要至少 8GB RAM，因為它運行時使用的是自己的電腦，而非廠商提供的伺服器。\nOllama 安裝與設定首先，前往 Ollama 官網 下載並安裝 Ollama。完成後，打開命令提示字元並輸入以下指令：\nollama run llava:7b\n\n按下 Enter 鍵後，系統將自動下載 4.7GB 的預訓練模型。下載完成後，即可開始與 AI 互動，無論是中文或英文都能得到回應。\n\n建立 Spring 專案接著，我們將在 Spring 專案中整合 Ollama。打開 Spring Initializr，按照以下設定創建專案。\n\n連接 Ollama開啟專案後，修改 application.properties 文件，加入 Ollama 的相關設定。其中，base-url 是 Ollama API 的位址，model 表示所使用的模型名稱。\nspring.ai.ollama.base-url=http://localhost:11434spring.ai.ollama.chat.model=llava:7b\n\n建立 Controller新增 OllamaController.java 來處理 AI 聊天和圖片辨識請求。\n@RestControllerpublic class OllamaController &#123;    private final OllamaChatModel ollamaChatModel;    public OllamaController(OllamaChatModel ollamaChatModel) &#123;        this.ollamaChatModel = ollamaChatModel;    &#125;    @RequestMapping(&quot;/ai&quot;)    public String ollama(@RequestParam(value = &quot;message&quot;) String message) &#123;        return ollamaChatModel.call(message);    &#125;&#125;\n\n程式碼連結程式碼下載\n測試啟動專案後，先測試 AI 問答功能。\n\n使用 API 測試工具發送 GET 請求至 http://localhost:8080/ai?message=你好\n\nmessage= 後方的內容即為傳送給 AI 的聊天內容。回應結果可在 Response Body 中查看。\n\n接著，測試圖片辨識功能：\n\n發送 GET 請求至 http://localhost:8080/ai?message=What's in this image?https://cdn.pixabay.com/photo/2014/10/14/20/24/ball-488717_1280.jpg\n\n稍待片刻，AI 將回應這是一張足球的圖片。\n\n此外，AI 還能協助撰寫程式：\n\n發送 GET 請求至 http://localhost:8080/ai?message=寫一個計算費波那契數列的Java程式\n\n\n對於未完成的程式，AI 也能接續完成，例如常見的 Two Sum 題目：\n\n發送 GET 請求至 http://localhost:8080/ai?message=完成剩下的程式public int twoSum(int nums, int target) Map Integer, Integer map = new HashMap()\n\n\n","categories":["Java"],"tags":["Java","Spring Boot","RESTful API","Ollama"]},{"title":"Spring Boot project-oriented programming（25）安裝Node.js和Visual Studio Code","url":"/2024/11/03/spring-boot-pop-25/","content":"在先前的專案設計中，我們採用了極簡主義風格，外觀相對簡約。接下來，我們將介紹如何利用流行的前端框架，來設計更加美觀的前端專案。\n後端工程師為何要學習前端？許多後端工程師認為專注於後端開發即可，無需了解前端技術。然而，現實中，台灣的後端工程師往往最終都會轉向全端開發，要求具備前後端的技能。大部分後端工程師的第一份工作，通常是協助公司承接外包項目，這些項目可能僅需後端開發，但也可能包含全端需求。\n當分配到全端項目時，工程師需獨立完成前後端的開發工作，因此，掌握前端框架將對職業發展大有裨益。\n常用的前端框架目前流行的前端框架主要是 React 和 Vue.js。這兩個框架在 GitHub 上的星數皆超過二十萬，遠超過 Python 和 Linux 的星數，顯示了它們的受歡迎程度。\n安裝 Node.js不論是 React 還是 Vue.js，都需要使用 Node.js。以下是安裝步驟：\n\n前往官網 https://nodejs.org/ 。\n點擊「Download Node.js (LTS)」以下載 Node.js，LTS 版本穩定且會持續更新修補漏洞。\n\n安裝完成後，打開命令提示字元，輸入 node -v 確認安裝是否成功。若安裝成功，會顯示類似 v20.16.0 的版本號。\n\n安裝 Visual Studio Code接著安裝 Visual Studio Code（VS Code），這是一款免費的編輯器，廣受前端工程師使用。前往官網 https://code.visualstudio.com/Download 下載並安裝 VS Code。\n以下是幾個推薦的 VS Code 擴充功能，能有效提升開發效率：\n\nChinese (Traditional) Language Pack for Visual Studio Code讓 VS Code 界面顯示為中文，方便使用。\n\nES7+ React&#x2F;Redux&#x2F;React-Native snippets預設新增 JavaScript 或 TypeScript 檔案時，檔案內容是空白的，需要自行補上代碼。此擴充能簡化常見的代碼結構，例如輸入 rafce 會自動產生以下內容：\nimport React from &#x27;react&#x27;;const Page = () =&gt; &#123;  return (    &lt;div&gt;Page&lt;/div&gt;  );&#125;export default Page;\n\n輸入 rfc 則產生：\nimport React from &#x27;react&#x27;;export default function Page() &#123;  return (    &lt;div&gt;Page&lt;/div&gt;  );&#125;\n\nPrettier - Code formatter排版 HTML 或 JavaScript 時，手動對齊內容可能較為繁瑣。安裝 Prettier 後，可以自動格式化代碼。右鍵選擇「格式化文件」，即能快速讓代碼變得整齊。\n\n\n"},{"title":"Spring Boot project-oriented programming（26）React 打造 RESTful API前端：使用 Vite、Bun 與 Tailwind CSS","url":"/2024/11/04/spring-boot-pop-26/","content":"建立 React 專案本篇教學將帶你從頭建立一個 React 專案，並使用 Vite 工具來進行初始化設定。\n首先，打開 VSCode，選擇「開啟資料夾」並選定一個位置作為儲存 React 專案的資料夾。\n接著，進入「終端機」-&gt;「新增終端」開啟終端機。在終端機中輸入以下指令來建立 React 專案：\nnpm create vite@latest react-frontend-project\n\n\n在指令執行過程中，會進行一些設定選擇。請使用方向鍵選擇以下選項並按下 Enter 確定：\n\n選擇 React 作為框架。\n選擇 JavaScript 作為語言（本次專案會使用 JavaScript）。\n\n稍等片刻，專案初始化完成後，便會產生基本的 React 專案結構。\n\nBun 安裝與使用Bun 是一個更快速的套件管理工具，可以減少安裝套件和啟動專案的等待時間。我們將使用 Bun 來加速開發過程。\n在終端機中輸入以下指令來安裝 Bun：\nnpm install -g bun\n\n接下來，在終端機進入專案資料夾，並使用 Bun 安裝專案所需的套件：\nbun i\n\n稍候安裝完成後，啟動專案：\nbun run dev\n\n啟動成功後，終端機會顯示 http://localhost:5173/ 。按住 Ctrl 並點擊這段藍色文字，即可在瀏覽器中開啟專案，並看到「Vite + React」的畫面，表示設置成功。\n\n比較 Bun 與 npm 的速度Bun 在執行套件安裝時比 npm 更快。舉例來說：\nbun inpm i\n\n在這裡，Bun 完成安裝約需 618ms，而 npm 需要約 1 秒（1000ms），顯示 Bun 的顯著優勢。\n\nTailwind CSS 設定與安裝我們將使用 Tailwind CSS 加速樣式設計，它內建許多常用的 CSS 組合，能幫助我們快速構建頁面。\n在終端機中輸入以下指令安裝 Tailwind CSS：\nbun install -D tailwindcss postcss autoprefixerbunx tailwindcss init -p\n\n導入 Tailwind CSS 至專案在專案的 tailwind.config.js 檔案中，修改 content 設定如下：\n/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */export default &#123;  content: [    &quot;./index.html&quot;,    &quot;./src/**/*.&#123;js,ts,jsx,tsx&#125;&quot;,  ],  theme: &#123;    extend: &#123;&#125;,  &#125;,  plugins: [],&#125;\n\n打開 src/index.css，將原本的內容全部刪除並替換成以下代碼：\n@tailwind base;@tailwind components;@tailwind utilities;\n\n接著，在 App.jsx 中加入簡單的測試程式碼，確認 Tailwind CSS 正常運作：\nimport React from &quot;react&quot;;function App() &#123;\treturn (\t\t&lt;&gt;\t\t\t&lt;h1 className=&quot;text-3xl font-bold underline text-sky-500&quot;&gt;Hello world!&lt;/h1&gt;\t\t&lt;/&gt;\t);&#125;export default App;\n\n啟動專案，即可看到藍色的「Hello world!」字樣。\n\n導航列設計建立 src/components/navbar/Navbar.jsx，並從 Tailwind UI 中取得導航列範本。\n使用以下代碼構建導航列：\nimport &#123; Disclosure, DisclosureButton, DisclosurePanel &#125; from &quot;@headlessui/react&quot;;import &#123; Bars3Icon, XMarkIcon &#125; from &quot;@heroicons/react/24/outline&quot;;const navigation = [  &#123; name: &quot;Home&quot;, href: &quot;#&quot;, current: false &#125;,  &#123; name: &quot;Add Todo&quot;, href: &quot;#&quot;, current: false &#125;,];function classNames(...classes) &#123;  return classes.filter(Boolean).join(&quot; &quot;);&#125;export default function Navbar() &#123;  return (    &lt;Disclosure as=&quot;nav&quot; className=&quot;bg-gray-800&quot;&gt;      &lt;div className=&quot;mx-auto max-w-7xl px-2 sm:px-6 lg:px-8&quot;&gt;        &lt;div className=&quot;relative flex h-16 items-center justify-between&quot;&gt;          &lt;div className=&quot;absolute inset-y-0 left-0 flex items-center sm:hidden&quot;&gt;            &lt;DisclosureButton className=&quot;group relative inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white&quot;&gt;              &lt;Bars3Icon className=&quot;block h-6 w-6 group-data-[open]:hidden&quot; aria-hidden=&quot;true&quot; /&gt;              &lt;XMarkIcon className=&quot;hidden h-6 w-6 group-data-[open]:block&quot; aria-hidden=&quot;true&quot; /&gt;            &lt;/DisclosureButton&gt;          &lt;/div&gt;          &lt;div className=&quot;flex flex-1 items-center justify-center sm:items-stretch sm:justify-start&quot;&gt;            &lt;div className=&quot;hidden sm:ml-6 sm:block&quot;&gt;              &lt;div className=&quot;flex space-x-4&quot;&gt;                &#123;navigation.map((item) =&gt; (                  &lt;a key=&#123;item.name&#125; href=&#123;item.href&#125; className=&#123;classNames(item.current ? &quot;bg-gray-900 text-white&quot; : &quot;text-gray-300 hover:bg-gray-700 hover:text-white&quot;, &quot;rounded-md px-3 py-2 text-sm font-medium&quot;)&#125;&gt;                    &#123;item.name&#125;                  &lt;/a&gt;                ))&#125;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;DisclosurePanel className=&quot;sm:hidden&quot;&gt;        &lt;div className=&quot;space-y-1 px-2 pb-3 pt-2&quot;&gt;          &#123;navigation.map((item) =&gt; (            &lt;DisclosureButton key=&#123;item.name&#125; as=&quot;a&quot; href=&#123;item.href&#125; className=&#123;classNames(item.current ? &quot;bg-gray-900 text-white&quot; : &quot;text-gray-300 hover:bg-gray-700 hover:text-white&quot;, &quot;block rounded-md px-3 py-2 text-base font-medium&quot;)&#125;&gt;              &#123;item.name&#125;            &lt;/DisclosureButton&gt;          ))&#125;        &lt;/div&gt;      &lt;/DisclosurePanel&gt;    &lt;/Disclosure&gt;  );&#125;\n\n\n建立首頁頁面在 src/pages 資料夾下，建立 Home.jsx，用來放置首頁內容。加入一個測試表格，以確保排版正常：\nimport React from &quot;react&quot;;export default function Home() &#123;\treturn (\t\t&lt;div className=&quot;flex justify-center&quot;&gt;\t\t\t&lt;table className=&quot;table-auto w-full border border-gray-300&quot;&gt;\t\t\t\t&lt;thead&gt;\t\t\t\t\t&lt;tr className=&quot;bg-gray-200&quot;&gt;\t\t\t\t\t\t&lt;th className=&quot;border border-gray-300 px-4 py-2&quot;&gt;ID&lt;/th&gt;\t\t\t\t\t\t&lt;th className=&quot;border border-gray-300 px-4 py-2&quot;&gt;Title&lt;/th&gt;\t\t\t\t\t\t&lt;th className=&quot;border border-gray-300 px-4 py-2&quot;&gt;Completed&lt;/th&gt;\t\t\t\t\t\t&lt;th className=&quot;border border-gray-300 px-4 py-2&quot;&gt;Action&lt;/th&gt;\t\t\t\t\t&lt;/tr&gt;\t\t\t\t&lt;/thead&gt;\t\t\t\t&lt;tbody&gt;\t\t\t\t\t&lt;tr className=&quot;bg-white hover:bg-gray-100&quot;&gt;\t\t\t\t\t\t&lt;td className=&quot;border border-gray-300 px-4 py-2&quot;&gt;1&lt;/td&gt;\t\t\t\t\t\t&lt;td className=&quot;border border-gray-300 px-4 py-2&quot;&gt;Create Spring Boot Project&lt;/td&gt;\t\t\t\t\t\t&lt;td className=&quot;border border-gray-300 px-4 py-2&quot;&gt;True&lt;/td&gt;\t\t\t\t\t\t&lt;td className=&quot;border border-gray-300 px-4 py-2&quot;&gt;\t\t\t\t\t\t\t&lt;a href=&quot;#&quot; className=&quot;text-blue-500 hover:underline&quot;&gt;View&lt;/a&gt;\t\t\t\t\t\t\t&lt;a href=&quot;#&quot; className=&quot;text-orange-500 hover:underline&quot;&gt;Edit&lt;/a&gt;\t\t\t\t\t\t\t&lt;a href=&quot;#&quot; className=&quot;text-red-500 hover:underline&quot;&gt;Delete&lt;/a&gt;\t\t\t\t\t\t&lt;/td&gt;\t\t\t\t\t&lt;/tr&gt;\t\t\t\t&lt;/tbody&gt;\t\t\t&lt;/table&gt;\t\t&lt;/div&gt;\t);&#125;\n\n最後在 App.jsx 中將 Navbar 與 Home 組合在一起，並啟動專案確認效果：\nimport React from &quot;react&quot;;import Navbar from &quot;./components/navbar/Navbar&quot;;import Home from &quot;./pages/Home&quot;;function App() &#123;\treturn (\t\t&lt;&gt;\t\t\t&lt;Navbar /&gt;\t\t\t&lt;Home /&gt;\t\t&lt;/&gt;\t);&#125;export default App;\n\n\n以上就是建立 React 專案並快速使用 Tailwind CSS、Bun 與導航列的流程。\n","categories":["React"],"tags":["React","Restful API"]},{"title":"Spring Boot project-oriented programming（28）Vue.js 打造 RESTful API前端：註冊、登入與登出","url":"/2024/11/06/spring-boot-pop-28/","content":"我們現在要開始開發購物車專案的前端部分，使用的框架是Vue.js。\n建立專案\n打開VSCode，開啟終端機，輸入以下指令：\nbun create vue@latest\n\n依據以下設定完成專案初始化：\n✔ Project name: … shopping_cart_frontend✔ Add TypeScript? … No✔ Add JSX Support? … No✔ Add Vue Router for Single Page Application development? … Yes✔ Add Pinia for state management? … Yes✔ Add Vitest for Unit testing? … No✔ Add an End-to-End Testing Solution? … No✔ Add ESLint for code quality? … Yes✔ Add Prettier for code formatting? … No✔ Add Vue DevTools 7 extension for debugging? (experimental) … No\n\n安裝所需套件後，啟動專案：\ncd shopping_cart_frontendbun ibun dev\n\n在瀏覽器中前往 http://localhost:5173/ ，可以看到顯示「You did it!」的頁面，確認專案成功建立。\n\n\n刪除 asset 和 views 資料夾，並清空 components、router、stores 目錄內的文件。\n\n\n\n導入Tailwind CSS\n安裝Tailwind CSS的相關套件：\nbun install -D tailwindcss postcss autoprefixerbunx tailwindcss init -p\n\n修改 tailwind.config.js，設定Vue.js專案的內容：\n/** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */export default &#123;  content: [&#x27;./index.html&#x27;, &#x27;./src/**/*.&#123;vue,js,ts,jsx,tsx&#125;&#x27;],  theme: &#123;    extend: &#123;&#125;  &#125;,  plugins: []&#125;\n\n在 src 目錄下新增 style.css 檔案，並加入Tailwind CSS的基礎樣式：\n@tailwind base;@tailwind components;@tailwind utilities;\n\n在 main.js 中啟用Tailwind CSS：\nimport &#x27;./style.css&#x27;import &#123; createApp &#125; from &#x27;vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)app.use(createPinia())app.mount(&#x27;#app&#x27;)\n\n修改 App.vue 的內容對Tailwind CSS進行測試：\n&lt;script setup&gt;&lt;/script&gt;&lt;template&gt;  &lt;h1 class=&quot;text-3xl font-bold underline text-sky-500&quot;&gt;Hello world!&lt;/h1&gt;&lt;/template&gt;\n\n再次啟動專案，確認是否能看到帶藍色下劃線的「Hello world!」。\n\n\n\n\n建立導航列\n在 src/components 資料夾中新增 MainNavbar.vue。導航列的樣式可以參考 Tailwind UI 的導航列 。\n\n根據專案需求，修改導航列的圖示和選單內容，並設定「購物車」按鈕在點擊後導向 /cart 頁面。\n\n\n&lt;template&gt;\t&lt;Disclosure as=&quot;nav&quot; class=&quot;bg-gray-800&quot; v-slot=&quot;&#123; open &#125;&quot;&gt;\t\t&lt;div class=&quot;mx-auto max-w-7xl px-2 sm:px-6 lg:px-8&quot;&gt;\t\t\t&lt;div class=&quot;relative flex h-16 items-center justify-between&quot;&gt;\t\t\t\t&lt;div class=&quot;absolute inset-y-0 left-0 flex items-center sm:hidden&quot;&gt;\t\t\t\t\t&lt;!-- Mobile menu button--&gt;\t\t\t\t\t&lt;DisclosureButton\t\t\t\t\t\tclass=&quot;relative inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white&quot;\t\t\t\t\t&gt;\t\t\t\t\t\t&lt;span class=&quot;absolute -inset-0.5&quot; /&gt;\t\t\t\t\t\t&lt;span class=&quot;sr-only&quot;&gt;Open main menu&lt;/span&gt;\t\t\t\t\t\t&lt;Bars3Icon v-if=&quot;!open&quot; class=&quot;block h-6 w-6&quot; aria-hidden=&quot;true&quot; /&gt;\t\t\t\t\t\t&lt;XMarkIcon v-else class=&quot;block h-6 w-6&quot; aria-hidden=&quot;true&quot; /&gt;\t\t\t\t\t&lt;/DisclosureButton&gt;\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;div\t\t\t\t\tclass=&quot;flex flex-1 items-center justify-center sm:items-stretch sm:justify-start&quot;\t\t\t\t&gt;\t\t\t\t\t&lt;div class=&quot;hidden sm:ml-6 sm:block&quot;&gt;\t\t\t\t\t\t&lt;div class=&quot;flex space-x-4&quot;&gt;\t\t\t\t\t\t\t&lt;a\t\t\t\t\t\t\t\tv-for=&quot;item in navigation&quot;\t\t\t\t\t\t\t\t:key=&quot;item.name&quot;\t\t\t\t\t\t\t\t:href=&quot;item.href&quot;\t\t\t\t\t\t\t\t:class=&quot;[\t\t\t\t\t\t\t\t\titem.current\t\t\t\t\t\t\t\t\t\t? &#x27;bg-gray-900 text-white&#x27;\t\t\t\t\t\t\t\t\t\t: &#x27;text-gray-300 hover:bg-gray-700 hover:text-white&#x27;,\t\t\t\t\t\t\t\t\t&#x27;rounded-md px-3 py-2 text-sm font-medium&#x27;,\t\t\t\t\t\t\t\t]&quot;\t\t\t\t\t\t\t\t:aria-current=&quot;item.current ? &#x27;page&#x27; : undefined&quot;\t\t\t\t\t\t\t\t&gt;&#123;&#123; item.name &#125;&#125;&lt;/a\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;div\t\t\t\t\tclass=&quot;absolute inset-y-0 right-0 flex items-center pr-2 sm:static sm:inset-auto sm:ml-6 sm:pr-0&quot;\t\t\t\t&gt;\t\t\t\t\t&lt;button\t\t\t\t\t\ttype=&quot;button&quot;\t\t\t\t\t\tclass=&quot;relative rounded-full bg-gray-800 p-1 text-gray-400 hover:text-white focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-gray-800&quot;                        @click=&quot;goToCart&quot;                        &gt;\t\t\t\t\t\t&lt;span class=&quot;absolute -inset-1.5&quot; /&gt;\t\t\t\t\t\t&lt;span class=&quot;sr-only&quot;&gt;Shopping Cart&lt;/span&gt;                                                    &lt;ShoppingCartIcon class=&quot;h-6 w-6&quot; aria-hidden=&quot;true&quot;&gt;&lt;/ShoppingCartIcon&gt;\t\t\t\t\t\t                                           \t\t\t\t\t&lt;/button&gt;\t\t\t\t\t&lt;!-- Profile dropdown --&gt;\t\t\t\t\t&lt;Menu as=&quot;div&quot; class=&quot;relative ml-3&quot;&gt;\t\t\t\t\t\t&lt;div&gt;\t\t\t\t\t\t\t&lt;MenuButton\t\t\t\t\t\t\t\tclass=&quot;relative flex rounded-full bg-gray-800 text-sm focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-gray-800&quot;\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t\t&lt;span class=&quot;absolute -inset-1.5&quot; /&gt;\t\t\t\t\t\t\t\t&lt;span class=&quot;sr-only&quot;&gt;Open user menu&lt;/span&gt;\t\t\t\t\t\t\t\t&lt;UserIcon class=&quot;h-8 w-8 rounded-full bg-white&quot;&gt; &lt;/UserIcon&gt;\t\t\t\t\t\t\t&lt;/MenuButton&gt;\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t&lt;transition\t\t\t\t\t\t\tenter-active-class=&quot;transition ease-out duration-100&quot;\t\t\t\t\t\t\tenter-from-class=&quot;transform opacity-0 scale-95&quot;\t\t\t\t\t\t\tenter-to-class=&quot;transform opacity-100 scale-100&quot;\t\t\t\t\t\t\tleave-active-class=&quot;transition ease-in duration-75&quot;\t\t\t\t\t\t\tleave-from-class=&quot;transform opacity-100 scale-100&quot;\t\t\t\t\t\t\tleave-to-class=&quot;transform opacity-0 scale-95&quot;\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t&lt;MenuItems\t\t\t\t\t\t\t\tclass=&quot;absolute right-0 z-10 mt-2 w-48 origin-top-right rounded-md bg-white py-1 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none&quot;\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t\t&lt;MenuItem v-slot=&quot;&#123; active &#125;&quot;&gt;\t\t\t\t\t\t\t\t\t&lt;a\t\t\t\t\t\t\t\t\t\thref=&quot;/login&quot;\t\t\t\t\t\t\t\t\t\t:class=&quot;[\t\t\t\t\t\t\t\t\t\t\tactive ? &#x27;bg-gray-100&#x27; : &#x27;&#x27;,\t\t\t\t\t\t\t\t\t\t\t&#x27;block px-4 py-2 text-sm text-gray-700&#x27;,\t\t\t\t\t\t\t\t\t\t]&quot;\t\t\t\t\t\t\t\t\t\t&gt;Login&lt;/a\t\t\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t\t&lt;/MenuItem&gt;\t\t\t\t\t\t\t\t&lt;MenuItem v-slot=&quot;&#123; active &#125;&quot;&gt;\t\t\t\t\t\t\t\t\t&lt;a\t\t\t\t\t\t\t\t\t\thref=&quot;/signup&quot;\t\t\t\t\t\t\t\t\t\t:class=&quot;[\t\t\t\t\t\t\t\t\t\t\tactive ? &#x27;bg-gray-100&#x27; : &#x27;&#x27;,\t\t\t\t\t\t\t\t\t\t\t&#x27;block px-4 py-2 text-sm text-gray-700&#x27;,\t\t\t\t\t\t\t\t\t\t]&quot;\t\t\t\t\t\t\t\t\t\t&gt;Sign up&lt;/a\t\t\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t\t&lt;/MenuItem&gt;\t\t\t\t\t\t\t\t&lt;MenuItem v-slot=&quot;&#123; active &#125;&quot;&gt;\t\t\t\t\t\t\t\t\t&lt;a\t\t\t\t\t\t\t\t\t\thref=&quot;/signout&quot;\t\t\t\t\t\t\t\t\t\t:class=&quot;[\t\t\t\t\t\t\t\t\t\t\tactive ? &#x27;bg-gray-100&#x27; : &#x27;&#x27;,\t\t\t\t\t\t\t\t\t\t\t&#x27;block px-4 py-2 text-sm text-gray-700&#x27;,\t\t\t\t\t\t\t\t\t\t]&quot;\t\t\t\t\t\t\t\t\t\t&gt;Logout&lt;/a\t\t\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t\t&lt;/MenuItem&gt;\t\t\t\t\t\t\t&lt;/MenuItems&gt;\t\t\t\t\t\t&lt;/transition&gt;\t\t\t\t\t&lt;/Menu&gt;\t\t\t\t&lt;/div&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;DisclosurePanel class=&quot;sm:hidden&quot;&gt;\t\t\t&lt;div class=&quot;space-y-1 px-2 pb-3 pt-2&quot;&gt;\t\t\t\t&lt;DisclosureButton\t\t\t\t\tv-for=&quot;item in navigation&quot;\t\t\t\t\t:key=&quot;item.name&quot;\t\t\t\t\tas=&quot;a&quot;\t\t\t\t\t:href=&quot;item.href&quot;\t\t\t\t\t:class=&quot;[\t\t\t\t\t\titem.current\t\t\t\t\t\t\t? &#x27;bg-gray-900 text-white&#x27;\t\t\t\t\t\t\t: &#x27;text-gray-300 hover:bg-gray-700 hover:text-white&#x27;,\t\t\t\t\t\t&#x27;block rounded-md px-3 py-2 text-base font-medium&#x27;,\t\t\t\t\t]&quot;\t\t\t\t\t:aria-current=&quot;item.current ? &#x27;page&#x27; : undefined&quot;\t\t\t\t\t&gt;&#123;&#123; item.name &#125;&#125;&lt;/DisclosureButton\t\t\t\t&gt;\t\t\t&lt;/div&gt;\t\t&lt;/DisclosurePanel&gt;\t&lt;/Disclosure&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;\tDisclosure,\tDisclosureButton,\tDisclosurePanel,\tMenu,\tMenuButton,\tMenuItem,\tMenuItems,&#125; from &quot;@headlessui/vue&quot;;import &#123;\tBars3Icon,\tShoppingCartIcon,\tUserIcon,\tXMarkIcon,&#125; from &quot;@heroicons/vue/24/outline&quot;;const navigation = [&#123; name: &quot;Add Product&quot;, href: &quot;/add&quot;, current: true &#125;];const goToCart = () =&gt; &#123;    window.location.href = &quot;/cart&quot;;&#125;&lt;/script&gt;\n\n在 Vue.js 中，@click 事件會在按下元素時執行對應的 script。\n\n安裝所需套件bun i @headlessui/vue @heroicons/vue\n\n\n在 App.vue 中顯示 MainNavbar在 App.vue 中引入並顯示 MainNavbar 元件：\n&lt;script setup&gt;import MainNavbar from &quot;./components/MainNavbar.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;MainNavbar /&gt;&lt;/template&gt;\n\n接著，確認按下不同按鈕後，URL 的變化如下：\n\nAdd Product → http://localhost:5173/add\n購物車圖示 → http://localhost:5173/cart\n\n按下用戶頭像後，點擊出現的選項會導航到以下頁面：\n\nLogin → http://localhost:5173/login\nSign up → http://localhost:5173/signup\nLogout → http://localhost:5173/signout\n\n\n\n建立登入頁面並設定 Vue Router在上一步中，我們點擊了多個按鈕，雖然 URL 有變化，但頁面內容並未隨之更新。接下來，我們將導入 Vue Router，根據 URL 來顯示不同的頁面內容。\n啟用 Vue Router\n在 main.js 中啟用 Vue Router：\nimport &#x27;./style.css&#x27;import &#123; createApp &#125; from &#x27;vue&#x27;import &#123; createPinia &#125; from &#x27;pinia&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;const app = createApp(App)app.use(createPinia())app.use(router)app.mount(&#x27;#app&#x27;)\n\n建立 src/components/RegisterForm.vue：\n&lt;template&gt;  RegisterForm&lt;/template&gt;\n\n在 router/index.js 中增加註冊頁面的路由：\nimport RegisterForm from &quot;@/components/RegisterForm.vue&quot;import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;const router = createRouter(&#123;  history: createWebHistory(import.meta.env.BASE_URL),  routes: [    &#123;      path: &#x27;/signup&#x27;,      name: &#x27;signup&#x27;,      component: RegisterForm    &#125;  ]&#125;)export default router\n\n在 App.vue 中添加 &lt;RouterView /&gt;，讓內容隨 Vue Router 的設定進行切換：\n&lt;script setup&gt;import MainNavbar from &quot;./components/MainNavbar.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;MainNavbar /&gt;  &lt;RouterView /&gt;&lt;/template&gt;\n\n當點擊 Sign up 時，可以在導航列下方看到「RegisterForm」文字，表示 Vue Router 的設定正確。\n\n\n修改 MainNavbar.vue 使用 Vue Router最後，修改 MainNavbar.vue，導入 Vue Router，將切換頁面的 href 屬性換成 @click 事件，讓按下按鈕時執行 router.push 進行導航。\n&lt;template&gt;\t&lt;Disclosure as=&quot;nav&quot; class=&quot;bg-gray-800&quot; v-slot=&quot;&#123; open &#125;&quot;&gt;\t\t&lt;div class=&quot;mx-auto max-w-7xl px-2 sm:px-6 lg:px-8&quot;&gt;\t\t\t&lt;div class=&quot;relative flex h-16 items-center justify-between&quot;&gt;\t\t\t\t&lt;div class=&quot;absolute inset-y-0 left-0 flex items-center sm:hidden&quot;&gt;\t\t\t\t\t&lt;!-- Mobile menu button--&gt;\t\t\t\t\t&lt;DisclosureButton\t\t\t\t\t\tclass=&quot;relative inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white&quot;\t\t\t\t\t&gt;\t\t\t\t\t\t&lt;span class=&quot;absolute -inset-0.5&quot; /&gt;\t\t\t\t\t\t&lt;span class=&quot;sr-only&quot;&gt;Open main menu&lt;/span&gt;\t\t\t\t\t\t&lt;Bars3Icon v-if=&quot;!open&quot; class=&quot;block h-6 w-6&quot; aria-hidden=&quot;true&quot; /&gt;\t\t\t\t\t\t&lt;XMarkIcon v-else class=&quot;block h-6 w-6&quot; aria-hidden=&quot;true&quot; /&gt;\t\t\t\t\t&lt;/DisclosureButton&gt;\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;div\t\t\t\t\tclass=&quot;flex flex-1 items-center justify-center sm:items-stretch sm:justify-start&quot;\t\t\t\t&gt;\t\t\t\t\t&lt;div class=&quot;hidden sm:ml-6 sm:block&quot;&gt;\t\t\t\t\t\t&lt;div class=&quot;flex space-x-4&quot;&gt;\t\t\t\t\t\t\t&lt;a\t\t\t\t\t\t\t\tv-for=&quot;item in navigation&quot;\t\t\t\t\t\t\t\t:key=&quot;item.name&quot;\t\t\t\t\t\t\t\t@click=&quot;router.push(item.href)&quot;\t\t\t\t\t\t\t\t:class=&quot;[\t\t\t\t\t\t\t\t\titem.current\t\t\t\t\t\t\t\t\t\t? &#x27;bg-gray-900 text-white&#x27;\t\t\t\t\t\t\t\t\t\t: &#x27;text-gray-300 hover:bg-gray-700 hover:text-white&#x27;,\t\t\t\t\t\t\t\t\t&#x27;rounded-md px-3 py-2 text-sm font-medium&#x27;,\t\t\t\t\t\t\t\t]&quot;\t\t\t\t\t\t\t\t:aria-current=&quot;item.current ? &#x27;page&#x27; : undefined&quot;\t\t\t\t\t\t\t\t&gt;&#123;&#123; item.name &#125;&#125;&lt;/a\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;div\t\t\t\t\tclass=&quot;absolute inset-y-0 right-0 flex items-center pr-2 sm:static sm:inset-auto sm:ml-6 sm:pr-0&quot;\t\t\t\t&gt;\t\t\t\t\t&lt;button\t\t\t\t\t\ttype=&quot;button&quot;\t\t\t\t\t\tclass=&quot;relative rounded-full bg-gray-800 p-1 text-gray-400 hover:text-white focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-gray-800&quot;                        @click=&quot;router.push(&#x27;/cart&#x27;)&quot;                        &gt;\t\t\t\t\t\t&lt;span class=&quot;absolute -inset-1.5&quot; /&gt;\t\t\t\t\t\t&lt;span class=&quot;sr-only&quot;&gt;Shopping Cart&lt;/span&gt;                                                    &lt;ShoppingCartIcon class=&quot;h-6 w-6&quot; aria-hidden=&quot;true&quot;&gt;&lt;/ShoppingCartIcon&gt;\t\t\t\t\t\t                                           \t\t\t\t\t&lt;/button&gt;\t\t\t\t\t&lt;!-- Profile dropdown --&gt;\t\t\t\t\t&lt;Menu as=&quot;div&quot; class=&quot;relative ml-3&quot;&gt;\t\t\t\t\t\t&lt;div&gt;\t\t\t\t\t\t\t&lt;MenuButton\t\t\t\t\t\t\t\tclass=&quot;relative flex rounded-full bg-gray-800 text-sm focus:outline-none focus:ring-2 focus:ring-white focus:ring-offset-2 focus:ring-offset-gray-800&quot;\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t\t&lt;span class=&quot;absolute -inset-1.5&quot; /&gt;\t\t\t\t\t\t\t\t&lt;span class=&quot;sr-only&quot;&gt;Open user menu&lt;/span&gt;\t\t\t\t\t\t\t\t&lt;UserIcon class=&quot;h-8 w-8 rounded-full bg-white&quot;&gt; &lt;/UserIcon&gt;\t\t\t\t\t\t\t&lt;/MenuButton&gt;\t\t\t\t\t\t&lt;/div&gt;\t\t\t\t\t\t&lt;transition\t\t\t\t\t\t\tenter-active-class=&quot;transition ease-out duration-100&quot;\t\t\t\t\t\t\tenter-from-class=&quot;transform opacity-0 scale-95&quot;\t\t\t\t\t\t\tenter-to-class=&quot;transform opacity-100 scale-100&quot;\t\t\t\t\t\t\tleave-active-class=&quot;transition ease-in duration-75&quot;\t\t\t\t\t\t\tleave-from-class=&quot;transform opacity-100 scale-100&quot;\t\t\t\t\t\t\tleave-to-class=&quot;transform opacity-0 scale-95&quot;\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t&lt;MenuItems\t\t\t\t\t\t\t\tclass=&quot;absolute right-0 z-10 mt-2 w-48 origin-top-right rounded-md bg-white py-1 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none&quot;\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t\t&lt;MenuItem v-slot=&quot;&#123; active &#125;&quot;&gt;\t\t\t\t\t\t\t\t\t&lt;a\t\t\t\t\t\t\t\t\t@click=&quot;router.push(&#x27;/login&#x27;)&quot;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t:class=&quot;[\t\t\t\t\t\t\t\t\t\t\tactive ? &#x27;bg-gray-100&#x27; : &#x27;&#x27;,\t\t\t\t\t\t\t\t\t\t\t&#x27;block px-4 py-2 text-sm text-gray-700&#x27;,\t\t\t\t\t\t\t\t\t\t]&quot;\t\t\t\t\t\t\t\t\t\t&gt;Login&lt;/a\t\t\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t\t&lt;/MenuItem&gt;\t\t\t\t\t\t\t\t&lt;MenuItem v-slot=&quot;&#123; active &#125;&quot;&gt;\t\t\t\t\t\t\t\t\t&lt;a\t\t\t\t\t\t\t\t\t@click=&quot;router.push(&#x27;/signup&#x27;)&quot;\t\t\t\t\t\t\t\t\t\t:class=&quot;[\t\t\t\t\t\t\t\t\t\t\tactive ? &#x27;bg-gray-100&#x27; : &#x27;&#x27;,\t\t\t\t\t\t\t\t\t\t\t&#x27;block px-4 py-2 text-sm text-gray-700&#x27;,\t\t\t\t\t\t\t\t\t\t]&quot;\t\t\t\t\t\t\t\t\t\t&gt;Sign up&lt;/a\t\t\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t\t&lt;/MenuItem&gt;\t\t\t\t\t\t\t\t&lt;MenuItem v-slot=&quot;&#123; active &#125;&quot;&gt;\t\t\t\t\t\t\t\t\t&lt;a\t\t\t\t\t\t\t\t\t\t:class=&quot;[\t\t\t\t\t\t\t\t\t\t\tactive ? &#x27;bg-gray-100&#x27; : &#x27;&#x27;,\t\t\t\t\t\t\t\t\t\t\t&#x27;block px-4 py-2 text-sm text-gray-700&#x27;,\t\t\t\t\t\t\t\t\t\t]&quot;\t\t\t\t\t\t\t\t\t\t@click=&quot;logout&quot;\t\t\t\t\t\t\t\t\t\t&gt;Logout&lt;/a\t\t\t\t\t\t\t\t\t&gt;\t\t\t\t\t\t\t\t&lt;/MenuItem&gt;\t\t\t\t\t\t\t&lt;/MenuItems&gt;\t\t\t\t\t\t&lt;/transition&gt;\t\t\t\t\t&lt;/Menu&gt;\t\t\t\t&lt;/div&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;DisclosurePanel class=&quot;sm:hidden&quot;&gt;\t\t\t&lt;div class=&quot;space-y-1 px-2 pb-3 pt-2&quot;&gt;\t\t\t\t&lt;DisclosureButton\t\t\t\t\tv-for=&quot;item in navigation&quot;\t\t\t\t\t:key=&quot;item.name&quot;\t\t\t\t\t@click=&quot;router.push(item.href)&quot;\t\t\t\t\t:class=&quot;[\t\t\t\t\t\titem.current\t\t\t\t\t\t\t? &#x27;bg-gray-900 text-white&#x27;\t\t\t\t\t\t\t: &#x27;text-gray-300 hover:bg-gray-700 hover:text-white&#x27;,\t\t\t\t\t\t&#x27;block rounded-md px-3 py-2 text-base font-medium&#x27;,\t\t\t\t\t]&quot;\t\t\t\t\t:aria-current=&quot;item.current ? &#x27;page&#x27; : undefined&quot;\t\t\t\t\t&gt;&#123;&#123; item.name &#125;&#125;&lt;/DisclosureButton\t\t\t\t&gt;\t\t\t&lt;/div&gt;\t\t&lt;/DisclosurePanel&gt;\t&lt;/Disclosure&gt;&lt;/template&gt;&lt;script setup&gt;import &#123;\tDisclosure,\tDisclosureButton,\tDisclosurePanel,\tMenu,\tMenuButton,\tMenuItem,\tMenuItems,&#125; from &quot;@headlessui/vue&quot;;import &#123;\tBars3Icon,\tShoppingCartIcon,\tUserIcon,\tXMarkIcon,&#125; from &quot;@heroicons/vue/24/outline&quot;;import router from &quot;@/router&quot;;const navigation = [&#123; name: &quot;Home&quot;, href: &quot;/&quot;, current: false &#125;,&#123; name: &quot;Add Product&quot;, href: &quot;/add&quot;, current: false &#125;];const logout = () =&gt; &#123;  router.push(&quot;/&quot;);&#125;;&lt;/script&gt;\n\n\n在 Vue 中實現註冊和登入功能以下是 RegisterForm.vue 的程式碼：\n&lt;template&gt;\t&lt;div class=&quot;flex justify-center min-h-screen items-center bg-gray-100&quot;&gt;\t\t&lt;form\t\t\tmethod=&quot;post&quot;\t\t\trole=&quot;form&quot;\t\t\tclass=&quot;bg-white p-6 rounded-lg shadow-md w-full max-w-md&quot;\t\t\t@submit.prevent=&quot;handleSubmit&quot;\t\t&gt;\t\t\t&lt;div class=&quot;mb-4&quot;&gt;\t\t\t\t&lt;label class=&quot;text-gray-700 font-bold mb-2&quot;&gt;Email&lt;/label&gt;\t\t\t\t&lt;input\t\t\t\t\tplaceholder=&quot;Enter email address&quot;\t\t\t\t\ttype=&quot;text&quot;\t\t\t\t\tclass=&quot;shadow border rounded w-full py-2 px-3 text-gray-700&quot;\t\t\t\t\tname=&quot;email&quot;\t\t\t\t\tautocomplete=&quot;current-email&quot;\t\t\t\t\tv-model=&quot;email&quot;\t\t\t\t/&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;div class=&quot;mb-4&quot;&gt;\t\t\t\t&lt;label class=&quot;text-gray-700 font-bold mb-2&quot;&gt;Password&lt;/label&gt;\t\t\t\t&lt;input\t\t\t\t\tplaceholder=&quot;Enter password&quot;\t\t\t\t\ttype=&quot;password&quot;\t\t\t\t\tclass=&quot;shadow border rounded w-full py-2 px-3 text-gray-700&quot;\t\t\t\t\tname=&quot;password&quot;\t\t\t\t\tautocomplete=&quot;current-password&quot;\t\t\t\t\tv-model=&quot;password&quot;\t\t\t\t/&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;button\t\t\t\ttype=&quot;submit&quot;\t\t\t\tclass=&quot;bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded&quot;\t\t\t&gt;\t\t\t\tRegister\t\t\t&lt;/button&gt;\t\t&lt;/form&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;;import &#123; useRouter &#125; from &#x27;vue-router&#x27;;export default &#123;  setup() &#123;    const router = useRouter();    const email = ref(&#x27;&#x27;);    const password = ref(&#x27;&#x27;);    const handleSubmit = () =&gt; &#123;      console.log(email.value);      console.log(password.value);      router.push(&#x27;/&#x27;);    &#125;;    return &#123;      email,      password,      handleSubmit,    &#125;;  &#125;,&#125;;&lt;/script&gt;\n\n\n@submit.prevent 的作用是攔截表單的預設行為，交由 Vue 的 handleSubmit 方法處理，避免頁面刷新。\nv-model 直接將表單輸入值綁定到 email 和 password 變數中，便於讀取和使用。\n\n測試表單送出功能在填寫表單的 email 和 password 欄位後，按下 Register，可以在瀏覽器的 Console 看到剛剛輸入的值，確認表單資料是否正確。\n\n\n設定 Spring Boot 的 CORS在 SecurityConfig.java 文件中配置 CORS，以允許 Vue 與後端通訊：\n.cors(cors -&gt; cors.configurationSource(new CorsConfigurationSource() &#123;                    @Override                    public CorsConfiguration getCorsConfiguration(HttpServletRequest request) &#123;                        CorsConfiguration config = new CorsConfiguration();                        config.setAllowedOrigins(Arrays.asList(&quot;http://localhost:5173&quot;));                        config.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;));                        config.setAllowCredentials(true);                        config.setExposedHeaders(Arrays.asList(&quot;Authorization&quot;));                        config.setAllowedHeaders(Arrays.asList(&quot;Authorization&quot;, &quot;Content-Type&quot;));                        config.setMaxAge(3600L);                        return config;                    &#125;                &#125;))\n\n這樣可以允許前端和後端之間的跨域請求。\n\n安裝 Axios 並傳送註冊請求安裝 axios：\nbun i axios\n\n接著修改 RegisterForm.vue 中的 handleSubmit 方法，讓其向後端傳送註冊請求：\nconst handleSubmit = async () =&gt; &#123;  try &#123;    const response = await axios.post(&#x27;http://localhost:8080/auth/signup&#x27;, &#123;      email: email.value,      password: password.value,    &#125;);    console.log(response.data);    router.push(&#x27;/&#x27;);  &#125; catch (error) &#123;    alert(&quot;Email already exists&quot;);    console.log(error);  &#125;&#125;;\n\n若註冊成功，Console 中會顯示 JSON 格式的訊息，例如：\n&#123; jwt: &#x27;eyJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE3MjMyNjk0NTYsImV4c…9tIn0.wxhXF6khkLpLwI2iKzQ4SLq5nyKNWn9SufnZ8zvJYkI&#x27;, message: &#x27;Signup Success&#x27; &#125;\n\n\n\n使用 Pinia 管理登入狀態建立 src/stores/auth.js，用來管理登入狀態：\nimport &#123; defineStore &#125; from &#x27;pinia&#x27;;export const useAuthStore = defineStore(&#x27;auth&#x27;, &#123;  state: () =&gt; (&#123;    token: null,  &#125;),  getters: &#123;    isAuthenticated: (state) =&gt; !!state.token,  &#125;,  actions: &#123;    setToken(token) &#123;      this.token = token;    &#125;,    clearToken() &#123;      this.token = null;    &#125;,  &#125;,&#125;);\n\n\n登入頁面設定複製 RegisterForm.vue，並重新命名為 LoginForm.vue：\n\n修改按鈕文字為 Login\n更新 axios.post 的 URL 為 http://localhost:8080/auth/login\n更改錯誤訊息為 “Invalid email or password”\n\n在 router/index.js 中添加路由設定：\nroutes: [  &#123;    path: &#x27;/signup&#x27;,    name: &#x27;signup&#x27;,    component: RegisterForm  &#125;,  &#123;    path: &#x27;/login&#x27;,    name: &#x27;login&#x27;,    component: LoginForm  &#125;]\n\n這樣就能測試登入頁面功能。填寫正確的帳號和密碼後，應該可以成功登入。\n\n\n這樣就完成了前端的註冊和登入功能。\n","categories":["Vue.js"],"tags":["Restful API","Vue.js"]},{"title":"Spring Boot project-oriented programming（27）React 打造 RESTful API前端：串接後端完成CRUD","url":"/2024/11/05/spring-boot-pop-27/","content":"從 Spring Boot 取得資料目前表格顯示的是假資料，我們需要從 Spring Boot 專案取得真實的資料。本次範例使用的是待辦事項清單（第二個專案）。\n\n安裝 axios我們將使用 axios 來與 RESTful API 溝通，首先安裝 axios。\nbun i axios\n\n\n在 Home.jsx 取得 Todo 資料在 Home.jsx 中使用 axios 發送請求來獲取 Todo 資料。\nimport React, &#123; useEffect, useState &#125; from &quot;react&quot;;import axios from &quot;axios&quot;;export default function Home() &#123;    const [todos, setTodos] = useState([]);    useEffect(() =&gt; &#123;        loadTodos();    &#125;, []);    const loadTodos = async () =&gt; &#123;        const res = await axios.get(&quot;http://localhost:8080/api/todo/all&quot;);        setTodos(res.data);        console.log(res.data);    &#125;;    return (        &lt;div&gt;            &#123;/* Render todos here */&#125;        &lt;/div&gt;    );&#125;\n\n\n處理 CORS 問題為了讓前端能夠存取後端 API，我們需要在 Spring Boot 後端專案中啟用 CORS。\n在 TodoController.java 中添加 CORS 設定。\n@CrossOrigin(&quot;http://localhost:5173/&quot;)public class TodoController &#123;    // Controller code&#125;\n\n啟動後端和前端專案，確認 CORS 問題已解決。\n\n新增 Todo在 src/components/todo/AddTodo.jsx 中建立表單，讓使用者新增 Todo。\nimport React, &#123; useState &#125; from &quot;react&quot;;import axios from &quot;axios&quot;;import &#123; useNavigate &#125; from &quot;react-router-dom&quot;;export default function AddTodo() &#123;    const [todo, setTodo] = useState(&#123; title: &quot;&quot;, completed: false &#125;);    const navigate = useNavigate();    const onInputChange = (e) =&gt; &#123;        const &#123; name, value, type, checked &#125; = e.target;        setTodo(&#123; ...todo, [name]: type === &quot;checkbox&quot; ? checked : value &#125;);    &#125;;    const onSubmit = async (e) =&gt; &#123;        e.preventDefault();        await axios.post(&quot;http://localhost:8080/api/todo/&quot;, todo);        navigate(&quot;/&quot;);    &#125;;    return (        &lt;div className=&quot;flex justify-center min-h-screen items-center bg-gray-100&quot;&gt;            &lt;form                onSubmit=&#123;onSubmit&#125;                className=&quot;bg-white p-6 rounded-lg shadow-md w-full max-w-md&quot;            &gt;                &lt;div className=&quot;mb-4&quot;&gt;                    &lt;label className=&quot;text-gray-700 font-bold mb-2&quot;&gt;Title&lt;/label&gt;                    &lt;input                        type=&quot;text&quot;                        name=&quot;title&quot;                        value=&#123;todo.title&#125;                        onChange=&#123;onInputChange&#125;                        className=&quot;shadow border rounded w-full py-2 px-3 text-gray-700&quot;                    /&gt;                &lt;/div&gt;                &lt;div className=&quot;mb-4&quot;&gt;                    &lt;label className=&quot;text-gray-700 font-bold mb-2&quot;&gt;Completed&lt;/label&gt;                    &lt;input                        type=&quot;checkbox&quot;                        name=&quot;completed&quot;                        checked=&#123;todo.completed&#125;                        onChange=&#123;onInputChange&#125;                        className=&quot;mr-2 leading-tight&quot;                    /&gt;                &lt;/div&gt;                &lt;button type=&quot;submit&quot; className=&quot;bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded&quot;&gt;                    Add                &lt;/button&gt;            &lt;/form&gt;        &lt;/div&gt;    );&#125;\n\n\n切換頁面使用 react-router-dom 來實現頁面切換，安裝 react-router-dom。\nbun i react-router-dom\n\n在 App.jsx 中設置路由。\nimport React from &quot;react&quot;;import &#123; BrowserRouter as Router, Route, Routes &#125; from &quot;react-router-dom&quot;;import Home from &quot;./pages/Home&quot;;import AddTodo from &quot;./components/todo/AddTodo&quot;;function App() &#123;    return (        &lt;Router&gt;            &lt;Routes&gt;                &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125; /&gt;                &lt;Route path=&quot;/add&quot; element=&#123;&lt;AddTodo /&gt;&#125; /&gt;            &lt;/Routes&gt;        &lt;/Router&gt;    );&#125;export default App;\n\n\n將後端的 Todo 資料顯示在首頁在 Home.jsx 中將 todos 資料呈現出來。\n&lt;tbody&gt;    &#123;todos.map((todo) =&gt; (        &lt;tr key=&#123;todo.id&#125; className=&quot;bg-white hover:bg-gray-100&quot;&gt;            &lt;td className=&quot;border border-gray-300 px-4 py-2&quot;&gt;&#123;todo.id&#125;&lt;/td&gt;            &lt;td className=&quot;border border-gray-300 px-4 py-2&quot;&gt;&#123;todo.title&#125;&lt;/td&gt;            &lt;td className=&quot;border border-gray-300 px-4 py-2&quot;&gt;&#123;todo.completed ? &quot;Yes&quot; : &quot;No&quot;&#125;&lt;/td&gt;        &lt;/tr&gt;    ))&#125;&lt;/tbody&gt;\n\n\n完成 Todo 狀態更新與刪除在 Home.jsx 中加入更新及刪除的功能。\nconst setCompletedTodo = async (id) =&gt; &#123;    await axios.patch(`http://localhost:8080/api/todo/$&#123;id&#125;/completed`);    loadTodos();&#125;;const deleteTodo = async (id) =&gt; &#123;    await axios.delete(`http://localhost:8080/api/todo/$&#123;id&#125;`);    loadTodos();&#125;;\n\n\n編輯和查看 Todo複製 AddTodo.jsx 到 EditTodo.jsx 和 ViewTodo.jsx，並作相應修改。\n在 App.jsx 中添加路由。\n&lt;Route path=&quot;/edit/:id&quot; element=&#123;&lt;EditTodo /&gt;&#125; /&gt;&lt;Route path=&quot;/view/:id&quot; element=&#123;&lt;ViewTodo /&gt;&#125; /&gt;\n\n\n前端專案完成我們的前端 React 專案完成，能夠實現新增、查看、編輯、刪除、以及更改狀態的功能。\n","categories":["React"],"tags":["React","Restful API"]},{"title":"Spring Boot project-oriented programming（29）Vue.js 打造 RESTful API前端：持久化保存、顯示和篩選商品","url":"/2024/11/07/spring-boot-pop-29/","content":"持久化保存我們目前面臨一個大問題：登入後切換頁面會導致 token 消失，雖然使用 router.push 可以暫時解決，但按 F5 重新整理仍會讓 token 消失。\n為了解決這個問題，我們需要將 token 持久化保存，這樣就能確保 token 持續有效。\n\n步驟\n安裝 Pinia 持久化套件： 安裝 Pinia 的持久化套件，確保能夠長期保存 token。\n\nbun install pinia-plugin-persistedstate\n\n\n修改 main.js，啟用 Pinia 持久化： 在 main.js 中設定並啟用 Pinia 持久化功能。\n\nimport piniaPluginPersistedstate from &#x27;pinia-plugin-persistedstate&#x27;;pinia.use(piniaPluginPersistedstate)\n\n\n修改 auth.js，將 token 持久化： 在 auth.js 中設定 token 的持久化邏輯，確保每次登入後都能保存 token。\n\nexport const useAuthStore = defineStore(&#x27;auth&#x27;, &#123;  state: () =&gt; (&#123;    //...  &#125;),  getters: &#123;    //...  &#125;,  actions: &#123;    //...  &#125;,  persist: true,//啟用pinia持久化&#125;);\n\n這樣一來，無論是重新整理還是切換頁面，token 都不會消失。\n注意：token 過期後，由於持久化保存會殘留過期的 token，需要手動登出來清除 token。\n新增商品頁面\n建立 AddProduct.vue\n\n\n主要內容來自 LoginForm.vue，只是需要多幾個 。\n\n修改 axios 的 URL，並在傳送時加上 token。\n\n由於在 SpringBoot 設定中為了一次接收多筆產品資料，使用了 Product[]。 因此，即使只傳一筆資料，也需要在 data 中多加上 []。\n\n\n&lt;template&gt;\t&lt;div className=&quot;flex justify-center min-h-screen items-center bg-gray-100&quot;&gt;\t\t&lt;form\t\t\tmethod=&quot;post&quot;\t\t\trole=&quot;form&quot;\t\t\tclassName=&quot;bg-white p-6 rounded-lg shadow-md w-full max-w-md&quot;\t\t\t@submit.prevent=&quot;handleSubmit&quot;\t\t&gt;\t\t\t&lt;div className=&quot;mb-4&quot;&gt;\t\t\t\t&lt;label className=&quot;text-gray-700 font-bold mb-2&quot;&gt; Name &lt;/label&gt;\t\t\t\t&lt;input\t\t\t\t\tplaceholder=&quot;Enter product name&quot;\t\t\t\t\ttype=&quot;text&quot;\t\t\t\t\tclassName=&quot;shadow border rounded w-full py-2 px-3 text-gray-700&quot;\t\t\t\t\tname=&quot;name&quot;\t\t\t\t\tv-model=&quot;name&quot;\t\t\t\t/&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;div className=&quot;mb-4&quot;&gt;\t\t\t\t&lt;label className=&quot;text-gray-700 font-bold mb-2&quot;&gt; Description &lt;/label&gt;\t\t\t\t&lt;input\t\t\t\t\tplaceholder=&quot;Enter product description&quot;\t\t\t\t\ttype=&quot;text&quot;\t\t\t\t\tclassName=&quot;shadow border rounded w-full py-2 px-3 text-gray-700&quot;\t\t\t\t\tname=&quot;description&quot;\t\t\t\t\tv-model=&quot;description&quot;\t\t\t\t/&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;div className=&quot;mb-4&quot;&gt;\t\t\t\t&lt;label className=&quot;text-gray-700 font-bold mb-2&quot;&gt; Price &lt;/label&gt;\t\t\t\t&lt;input\t\t\t\t\tplaceholder=&quot;Enter product price&quot;\t\t\t\t\ttype=&quot;text&quot;\t\t\t\t\tclassName=&quot;shadow border rounded w-full py-2 px-3 text-gray-700&quot;\t\t\t\t\tname=&quot;price&quot;\t\t\t\t\tv-model=&quot;price&quot;\t\t\t\t/&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;div className=&quot;mb-4&quot;&gt;\t\t\t\t&lt;label className=&quot;text-gray-700 font-bold mb-2&quot;&gt; Image URL &lt;/label&gt;\t\t\t\t&lt;input\t\t\t\t\tplaceholder=&quot;Enter product image URL&quot;\t\t\t\t\ttype=&quot;text&quot;\t\t\t\t\tclassName=&quot;shadow border rounded w-full py-2 px-3 text-gray-700&quot;\t\t\t\t\tname=&quot;image&quot;\t\t\t\t\tv-model=&quot;image&quot;\t\t\t\t/&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;div className=&quot;mb-4&quot;&gt;\t\t\t\t&lt;label className=&quot;text-gray-700 font-bold mb-2&quot;&gt; Category &lt;/label&gt;\t\t\t\t&lt;input\t\t\t\t\tplaceholder=&quot;Enter product category&quot;\t\t\t\t\ttype=&quot;text&quot;\t\t\t\t\tclassName=&quot;shadow border rounded w-full py-2 px-3 text-gray-700&quot;\t\t\t\t\tname=&quot;category&quot;\t\t\t\t\tv-model=&quot;category&quot;\t\t\t\t/&gt;\t\t\t&lt;/div&gt;\t\t\t&lt;button\t\t\t\ttype=&quot;submit&quot;\t\t\t\tclassName=&quot;bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded&quot;\t\t\t&gt;\t\t\t\tAdd\t\t\t&lt;/button&gt;\t\t&lt;/form&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &quot;vue&quot;;import &#123; useRouter &#125; from &quot;vue-router&quot;;import axios from &quot;axios&quot;;import &#123; useAuthStore &#125; from &quot;@/stores/auth&quot;;export default &#123;\tsetup() &#123;\t\tconst router = useRouter();\t\tconst authStore = useAuthStore();\t\tconst name = ref(&quot;&quot;);\t\tconst description = ref(&quot;&quot;);\t\tconst price = ref(&quot;&quot;);\t\tconst image = ref(&quot;&quot;);\t\tconst category = ref(&quot;&quot;);\t\tconst handleSubmit = async () =&gt; &#123;\t\t\ttry &#123;\t\t\t\tconst token = authStore.token;\t\t\t\tif(!name.value || !description.value || !price.value || !image.value || !category.value || isNaN(price.value))&#123;\t\t\t\t\tthrow new Error(&quot;商品資料格式錯誤&quot;);\t\t\t\t&#125;\t\t\t\tconst data = [&#123;\t\t\t\t\tname: name.value,\t\t\t\t\tdescription: description.value,\t\t\t\t\tprice: parseInt(price.value),\t\t\t\t\timage: image.value,\t\t\t\t\tcategory: category.value,\t\t\t\t&#125;];\t\t\t\tconst response = await axios.post(\t\t\t\t\t&quot;http://localhost:8080/api/product/&quot;,\t\t\t\t\tdata,\t\t\t\t\t&#123;\t\t\t\t\t\theaders: &#123;\t\t\t\t\t\t\t&#x27;Authorization&#x27;: `Bearer $&#123;token&#125;`\t\t\t\t\t\t&#125;\t\t\t\t\t&#125;\t\t\t\t);\t\t\t\tconsole.log(response.data);\t\t\t\trouter.push(&quot;/&quot;);\t\t\t&#125; catch (error) &#123;\t\t\t\t\t\t\t\talert(&quot;Error&quot;);\t\t\t\tconsole.log(error);\t\t\t&#125;\t\t&#125;;\t\treturn &#123;\t\t\tname,\t\t\tdescription,\t\t\tprice,\t\t\timage,\t\t\tcategory,\t\t\thandleSubmit,\t\t&#125;;\t&#125;,&#125;;&lt;/script&gt;\n\n\n在 router&#x2F;index.js 添加路由\n\nroutes: [  &#123;    //  &#125;,  &#123;    //  &#125;,  &#123;    path: &#x27;/add&#x27;,    name: &#x27;add&#x27;,    component: AddProduct  &#125;]\n\n\n測試功能\n點擊 “Add Product”，嘗試新增商品資料。\n測試未填內容或價格非數字時會彈出錯誤視窗。\n\n首頁呈現商品內容\n新增 HomePage.vue\n\n\n用於顯示商品列表。\n\n&lt;template&gt;\t&lt;div v-if=&quot;isAuthenticated&quot; class=&quot;p-4 bg-gray-50 min-h-screen&quot;&gt;\t\t&lt;div\t\t\tv-for=&quot;product in products&quot;\t\t\t:key=&quot;product.id&quot;\t\t\tclass=&quot;flex items-center border-b border-gray-200 py-4&quot;\t\t&gt;\t\t\t&lt;img\t\t\t\t:src=&quot;product.image&quot;\t\t\t\t:alt=&quot;product.name&quot;\t\t\t\tclass=&quot;w-16 h-16 object-cover rounded-lg shadow-sm mr-4&quot;\t\t\t/&gt;\t\t\t&lt;div class=&quot;flex-1&quot;&gt;\t\t\t\t&lt;h2 class=&quot;text-lg font-bold text-gray-900&quot;&gt;&#123;&#123; product.name &#125;&#125;&lt;/h2&gt;\t\t\t\t&lt;p class=&quot;text-gray-700 text-sm&quot;&gt;&#123;&#123; product.description &#125;&#125;&lt;/p&gt;\t\t\t\t&lt;p class=&quot;text-green-600 font-semibold text-sm mt-1&quot;&gt;\t\t\t\t\tPrice: &#123;&#123; product.price &#125;&#125;\t\t\t\t&lt;/p&gt;\t\t\t\t&lt;p class=&quot;text-gray-500 text-xs mt-1&quot;&gt;\t\t\t\t\tCategory: &#123;&#123; product.category &#125;&#125;\t\t\t\t&lt;/p&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;\t&lt;div v-else class=&quot;p-4&quot;&gt;\t\t&lt;p class=&quot;text-red-600 font-medium&quot;&gt;Please log in to see the products.&lt;/p&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useAuthStore &#125; from &quot;@/stores/auth&quot;;import &#123; computed, onMounted, ref &#125; from &quot;vue&quot;;import axios from &quot;axios&quot;;const authStore = useAuthStore();const isAuthenticated = computed(() =&gt; authStore.isAuthenticated);//將商品資料提供給templateconst products = ref([]);const getProducts = async () =&gt; &#123;\ttry &#123;\t\tconst response = await axios.get(\t\t\t&quot;http://localhost:8080/api/product/?minPrice=&amp;maxPrice=&amp;category=&amp;sort=&amp;pageNumber=0&amp;pageSize=20&quot;,\t\t\t&#123;\t\t\t\theaders: &#123;\t\t\t\t\tAuthorization: `Bearer $&#123;authStore.token&#125;`,\t\t\t\t&#125;,\t\t\t&#125;\t\t);\t\t//把取得的商品資料放入products\t\tproducts.value = response.data.content;\t\tconsole.log(response.data);\t&#125; catch (error) &#123;\t\tconsole.log(error);\t&#125;&#125;;//等待template載入完成，再把商品資料放入templateonMounted(() =&gt; &#123;\tif (isAuthenticated.value) &#123;\t\tgetProducts();\t&#125;&#125;);&lt;/script&gt;\n\n\n在 router&#x2F;index.js 添加路由\n\nroutes: [  &#123;    //...  &#125;,  //...  &#123;    path: &#x27;/&#x27;,    name: &#x27;home&#x27;,    component: HomePage  &#125;]\n\n\n功能測試\n登入後即可看到資料庫中的商品。\n\n換頁功能\n安裝 vue-awesome-paginate\n\nbun i vue-awesome-paginate\n\n\n修改 HomePage.vue\n\n\n前往官方提供的範例 。\n\n根據範例修改 HomePage.vue。\n\n\n&lt;template&gt;\t&lt;div v-if=&quot;isAuthenticated&quot; class=&quot;p-4 bg-gray-50 min-h-screen&quot;&gt;\t\t&lt;div\t\t\tv-for=&quot;product in products&quot;\t\t\t:key=&quot;product.id&quot;\t\t\tclass=&quot;flex items-center border-b border-gray-200 py-4&quot;\t\t&gt;\t\t\t//...\t\t&lt;/div&gt;\t\t&lt;div class=&quot;flex justify-center&quot;&gt;\t\t\t&lt;vue-awesome-paginate\t\t\t\t:total-items=&quot;50&quot;\t\t\t\t:items-per-page=&quot;5&quot;\t\t\t\t:max-pages-shown=&quot;5&quot;\t\t\t\tv-model=&quot;currentPage&quot;\t\t\t\t@click=&quot;onClickHandler&quot;\t\t\t/&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;\t&lt;div v-else class=&quot;p-4&quot;&gt;\t\t//...\t&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;//...const onClickHandler = (page) =&gt; &#123;\tconsole.log(page);&#125;;const currentPage = ref(1);onMounted(() =&gt; &#123;\t//...&#125;);&lt;/script&gt;&lt;style&gt;.pagination-container &#123;\tdisplay: flex;\tcolumn-gap: 10px;&#125;.paginate-buttons &#123;\theight: 40px;\twidth: 40px;\tborder-radius: 20px;\tcursor: pointer;\tbackground-color: rgb(242, 242, 242);\tborder: 1px solid rgb(217, 217, 217);\tcolor: black;&#125;.paginate-buttons:hover &#123;\tbackground-color: #d8d8d8;&#125;.active-page &#123;\tbackground-color: #3498db;\tborder: 1px solid #3498db;\tcolor: white;&#125;.active-page:hover &#123;\tbackground-color: #2988c8;&#125;&lt;/style&gt;\n\n\n修改main.js啟用 VueAwesomePaginate\n\nimport VueAwesomePaginate from &#x27;vue-awesome-paginate&#x27;;import &quot;vue-awesome-paginate/dist/style.css&quot;;//...app.use(VueAwesomePaginate)\n\n\n測試換頁功能\n找到選擇頁面的地方，按下 &lt;、&gt; 和數字。\n觀察 Console 顯示的內容，是否和選擇的頁數相同。\n例如，按下 2，Console 也顯示 2。\n\n更改每頁顯示的數量\n增加顯示商品數量的選項\n\n\n增加一個選擇顯示商品數量的地方。\n\n&lt;template&gt;//...&lt;div class=&quot;flex justify-center&quot;&gt;\t\t\t&lt;vue-awesome-paginate\t\t\t\t:total-items=&quot;50&quot;\t\t\t\t:items-per-page=&quot;5&quot;\t\t\t\t:max-pages-shown=&quot;5&quot;\t\t\t\tv-model=&quot;currentPage&quot;\t\t\t\t@click=&quot;onClickHandler&quot;\t\t\t/&gt;\t\t\t\t&lt;select class=&quot;ml-4 bg-gray-200&quot; name=&quot;pageSize&quot; id=&quot;pageSize&quot; v-model=&quot;pageSize&quot; @change=&quot;onChangeHandler&quot;&gt;\t\t\t\t\t&lt;option value=&quot;5&quot;&gt;5&lt;/option&gt;\t\t\t\t\t&lt;option value=&quot;10&quot;&gt;10&lt;/option&gt;\t\t\t\t\t&lt;option value=&quot;15&quot;&gt;15&lt;/option&gt;\t\t\t\t\t&lt;option value=&quot;20&quot;&gt;20&lt;/option&gt;\t\t\t\t&lt;/select&gt;\t\t&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;//...const pageSize = ref(5);const onChangeHandler = () =&gt; &#123;\tconsole.log(pageSize.value);&#125;;&lt;/script&gt;\n\n測試：依次選擇 10、15、20、5，觀察內容變化時的 Console 輸出是否正確。\n預設值是 5，選擇 5 時內容沒有變化，需要選擇 10、15、20 才符合變化條件。\n\n\n讓頁面內容隨點擊變化\n\n使用 vue-awesome-paginate，接收來自後端的總商品數量，調整顯示最後一頁的頁碼。\n&lt;template&gt;//...&lt;div class=&quot;flex justify-center&quot;&gt;\t\t\t&lt;vue-awesome-paginate\t\t\t\t:total-items=&quot;totalElement&quot;\t\t\t\t:items-per-page=&quot;parseInt(pageSize)&quot;\t\t\t\t:max-pages-shown=&quot;5&quot;\t\t\t\tv-model=&quot;currentPage&quot;\t\t\t\t@click=&quot;onClickHandler&quot;\t\t\t/&gt;\t\t\t\t&lt;select class=&quot;ml-4 bg-gray-200&quot; name=&quot;pageSize&quot; id=&quot;pageSize&quot; v-model=&quot;pageSize&quot; @change=&quot;onChangeHandler&quot;&gt;\t\t\t\t\t&lt;option value=&quot;5&quot;&gt;5&lt;/option&gt;\t\t\t\t\t&lt;option value=&quot;10&quot;&gt;10&lt;/option&gt;\t\t\t\t\t&lt;option value=&quot;15&quot;&gt;15&lt;/option&gt;\t\t\t\t\t&lt;option value=&quot;20&quot;&gt;20&lt;/option&gt;\t\t\t\t&lt;/select&gt;\t\t&lt;/div&gt;\t\t//...&lt;/template&gt;\n\n修改 axios 根據前端設定的頁碼和每頁數量來取得商品資料，頁數需要從 0 開始，網頁從 1 開始，所以要減 1。\n&lt;script setup&gt;//...const totalElement = ref(1);const getProducts = async (page, size) =&gt; &#123;\ttry &#123;\t\tconst response = await axios.get(\t\t\t`http://localhost:8080/api/product/?minPrice=&amp;maxPrice=&amp;category=&amp;sort=&amp;pageNumber=$&#123;page - 1&#125;&amp;pageSize=$&#123;parseInt(size)&#125;`,\t\t\t&#123;\t\t\t\theaders: &#123;\t\t\t\t\tAuthorization: `Bearer $&#123;authStore.token&#125;`,\t\t\t\t&#125;,\t\t\t&#125;\t\t);\t\t//把取得的商品資料放入products\t\tproducts.value = response.data.content;\t\ttotalElement.value = response.data.totalElements;\t\tconsole.log(response.data);\t&#125; catch (error) &#123;\t\tconsole.log(error);\t&#125;&#125;;\n\n當切換頁碼和改變每頁顯示數量時，內容也要更新。\nconst onClickHandler = () =&gt; &#123;\tgetProducts(currentPage.value, pageSize.value);&#125;;const onChangeHandler = () =&gt; &#123;\tcurrentPage.value = 1;\tgetProducts(currentPage.value, pageSize.value);&#125;;\n\n由於我們修改了 getProducts 的傳入參數，需要在 onMounted 的部分增加參數。\nonMounted(() =&gt; &#123;\tif (isAuthenticated.value) &#123;\t\tgetProducts(currentPage.value, pageSize.value);\t&#125;&#125;);&lt;/script&gt;\n\n\n前端確認修改結果\n確認我們選擇 5 時，網頁上顯示的商品數量也是 5 個。\n\n根據條件篩選商品我們將在左邊放置篩選用的列表，右邊放商品內容。\n\n設置篩選區域\n\n\n在 v-if&#x3D;”isAuthenticated” 的 class 添加 flex。\n\n增加一個 ，用來放置過濾區塊，占用 1&#x2F;4 寬度。\n\n在顯示商品的外面，多加一層 ，讓它能使用 3&#x2F;4 寬度的版面。\n\n\n&lt;template&gt;\t&lt;div v-if=&quot;isAuthenticated&quot; class=&quot;p-4 bg-gray-50 min-h-screen flex&quot;&gt;\t\t&lt;div class=&quot;w-1/4 p-4&quot;&gt;\t\t\t&lt;div class=&quot;p-4 bg-gray-100 rounded-lg shadow-md&quot;&gt;\t\t\t\t&lt;div class=&quot;mb-4&quot;&gt;\t\t\t\t\t&lt;label class=&quot;block text-gray-700 font-bold mb-2&quot;&gt;Price&lt;/label&gt;\t\t\t\t\t&lt;div class=&quot;flex items-center&quot;&gt;\t\t\t\t\t\t&lt;input\t\t\t\t\t\t\tplaceholder=&quot;min&quot;\t\t\t\t\t\t\ttype=&quot;number&quot;\t\t\t\t\t\t\tclass=&quot;border p-2 mb-2 w-full mr-2 rounded&quot;\t\t\t\t\t\t\tv-model=&quot;minPrice&quot;\t\t\t\t\t\t/&gt;\t\t\t\t\t\t&lt;span class=&quot;mx-2&quot;&gt;to&lt;/span&gt;\t\t\t\t\t\t&lt;input\t\t\t\t\t\t\tplaceholder=&quot;max&quot;\t\t\t\t\t\t\ttype=&quot;number&quot;\t\t\t\t\t\t\tclass=&quot;border p-2 mb-2 w-full ml-2 rounded&quot;\t\t\t\t\t\t\tv-model=&quot;maxPrice&quot;\t\t\t\t\t\t/&gt;\t\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;div class=&quot;mb-4&quot;&gt;\t\t\t\t\t&lt;label class=&quot;block text-gray-700 font-bold mb-2&quot;&gt;Sort by:&lt;/label&gt;\t\t\t\t\t&lt;select class=&quot;border p-2 mb-4 w-full rounded&quot; v-model=&quot;sortBy&quot;&gt;\t\t\t\t\t\t&lt;option value=&quot;&quot;&gt;Default&lt;/option&gt;\t\t\t\t\t\t&lt;option value=&quot;price_low&quot;&gt;Price : Low to High&lt;/option&gt;\t\t\t\t\t\t&lt;option value=&quot;price_high&quot;&gt;Price : High to Low&lt;/option&gt;\t\t\t\t\t&lt;/select&gt;\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;div class=&quot;mb-4&quot;&gt;\t\t\t\t&lt;label class=&quot;block text-gray-700 font-bold mb-2&quot;&gt;Category:&lt;/label&gt;\t\t\t\t&lt;div v-for=&quot;category in categories&quot; :key=&quot;category&quot; class=&quot;mb-2&quot;&gt;\t\t\t\t\t&lt;input\t\t\t\t\t\ttype=&quot;radio&quot;\t\t\t\t\t\t:value=&quot;category&quot;\t\t\t\t\t\tv-model=&quot;categoryType&quot;\t\t\t\t\t\tclass=&quot;mr-2&quot;\t\t\t\t\t/&gt;\t\t\t\t\t&lt;label class=&quot;text-gray-700&quot;&gt;&#123;&#123; category ? category : &quot;All&quot; &#125;&#125;&lt;/label&gt;\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;/div&gt;\t\t\t\t&lt;button\t\t\t\t\tclass=&quot;bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-full&quot;\t\t\t\t\t@click=&quot;filterHandler&quot;\t\t\t\t&gt;\t\t\t\t\tFilter\t\t\t\t&lt;/button&gt;\t\t\t&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;div class=&quot;w-3/4 p-4&quot;&gt;\t\t\t&lt;div\t\t\t\tv-for=&quot;product in products&quot;\t\t\t\t:key=&quot;product.id&quot;\t\t\t\tclass=&quot;flex items-center border-b border-gray-200 py-4&quot;\t\t\t&gt;\t\t\t\t//...\t\t\t&lt;/div&gt;\t\t\t//...\t\t&lt;/div&gt;\t&lt;/div&gt;\t&lt;div v-else class=&quot;p-4&quot;&gt;\t\t&lt;p class=&quot;text-red-600 font-medium&quot;&gt;Please log in to see the products.&lt;/p&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;//...const categories = [\t&quot;&quot;,\t&quot;Bags&quot;,\t&quot;Shoe&quot;,\t&quot;Headset&quot;,\t&quot;Mice&quot;,\t&quot;Keyboard&quot;,\t&quot;Chair&quot;,\t&quot;Dinnerware&quot;,\t&quot;Light&quot;,\t&quot;Jean&quot;,];const categoryType = ref(&quot;&quot;);const minPrice = ref(&quot;&quot;);const maxPrice = ref(&quot;&quot;);const sortBy = ref(&quot;&quot;);//...const filterHandler = () =&gt; &#123;\tconsole.log(minPrice.value, maxPrice.value, categoryType.value, sortBy.value);&#125;;//...&lt;/script&gt;\n\n測試功能\n填寫最低價、最高價、排序方式、商品類別後，按下 Filter 按鈕，就能看到預計傳給後端的參數。\n可以看到和我們選擇的內容一樣，有相同的數值。\n\n\n實現過濾商品功能\n\n確認參數沒問題後，完成過濾商品功能。\n修改 getProducts 的輸入參數，並在使用到 getProducts 的地方增加傳入的參數。\nconst getProducts = async (min, max, category, sort, page, size) =&gt; &#123;\ttry &#123;\t\tconst response = await axios.get(\t\t\t`http://localhost:8080/api/product/?minPrice=$&#123;\t\t\t\tmin\t\t\t&#125;&amp;maxPrice=$&#123;\t\t\t\tmax\t\t\t&#125;&amp;category=$&#123;category&#125;&amp;sort=$&#123;sort&#125;&amp;pageNumber=$&#123;\t\t\t\tpage - 1\t\t\t&#125;&amp;pageSize=$&#123;parseInt(size)&#125;`,\t\t\t&#123;\t\t\t\theaders: &#123;\t\t\t\t\tAuthorization: `Bearer $&#123;authStore.token&#125;`,\t\t\t\t&#125;,\t\t\t&#125;\t\t);\t\tproducts.value = response.data.content;\t\ttotalElement.value = response.data.totalElements;\t\tconsole.log(response.data);\t&#125; catch (error) &#123;\t\tconsole.log(error);\t&#125;&#125;;const onClickHandler = () =&gt; &#123;\tgetProducts(minPrice.value, maxPrice.value, categoryType.value, sortBy.value, currentPage.value, pageSize.value);&#125;;const onChangeHandler = () =&gt; &#123;\tcurrentPage.value = 1;\tgetProducts(minPrice.value, maxPrice.value, categoryType.value, sortBy.value, currentPage.value, pageSize.value);&#125;;const filterHandler = () =&gt; &#123;\tcurrentPage.value = 1;\tgetProducts(minPrice.value, maxPrice.value, categoryType.value, sortBy.value, currentPage.value, pageSize.value);&#125;;onMounted(() =&gt; &#123;\tif (isAuthenticated.value) &#123;\t\tgetProducts(minPrice.value, maxPrice.value, categoryType.value, sortBy.value, currentPage.value, pageSize.value);\t&#125;&#125;);\n\n我們可以修改最低價、最高價、排序設定、商品類別，來測試篩選結果。\n\n設定 200-999，Price：Low To High，Category：All 顯示價格從 200 到 999 的商品，價格由低到高排序。\n\n\n\n設定 699-699，Price：High To Low，Category：Keyboard 只會顯示價格為 699 的 Keyboard 商品。\n\n\n","categories":["Vue.js"],"tags":["Restful API","Vue.js"]},{"title":"Spring Boot project-oriented programming（30）Vue.js 打造 RESTful API前端：購物車和導入SSL","url":"/2024/11/08/spring-boot-pop-30/","content":"將商品加入購物車功能實作我們將在 HomePage.vue 中為商品添加「Add To Cart」按鈕，讓使用者可以將商品加入購物車。\n按鈕添加在「Category:  product.category 」下方。\n&lt;p class=&quot;text-gray-500 text-xs mt-1&quot;&gt;\tCategory: &#123;&#123; product.category &#125;&#125;&lt;/p&gt;&lt;button\tclass=&quot;bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded&quot;\t@click=&quot;cartHandler(product.id)&quot;&gt;\tAdd To Cart&lt;/button&gt;\n\n點擊按鈕後，會將商品的 id 傳遞給 cartHandler 函數。\nconst cartHandler = (id) =&gt; &#123;\tconsole.log(id);&#125;;\n\n在按下「Add To Cart」後，商品的 id 就會被傳遞給處理程序。\n\n使用 axios 將商品加入購物車接著，我們使用 axios 發送請求來將商品加入購物車。\nconst cartHandler = (id) =&gt; &#123;\taddToCart(id);&#125;;const addToCart = async (id) =&gt; &#123;\ttry &#123;\t\tconst data = &#123;\t\t\tproductId: id,\t\t\tquantity: 1,\t\t&#125;;\t\tconst response = await axios.put(\t\t\t&quot;http://localhost:8080/api/cart/add&quot;,\t\t\tdata,\t\t\t&#123;\t\t\t\theaders: &#123;\t\t\t\t\tAuthorization: `Bearer $&#123;authStore.token&#125;`,\t\t\t\t&#125;,\t\t\t&#125;\t\t);\t\tconsole.log(response.data);\t&#125; catch (error) &#123;\t\tconsole.log(error);\t&#125;&#125;;\n\n顯示通知泡泡訊息 (Bubble)按下「Add To Cart」後，網頁會顯示一則通知，兩秒後自動消失。我們在 HomePage.vue 中設定此通知的顯示方式，也可以點擊它來手動關閉。\n&lt;div\tv-if=&quot;showBubble&quot;\tclass=&quot;fixed top-8 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg transition-opacity duration-500 ease-in-out&quot;\t@click=&quot;closeBubble&quot;&gt;\tAdded to Cart!&lt;/div&gt;\n\n在 script 部分設定點擊「Add To Cart」後的顯示邏輯，並設定自動消失的計時器。\nconst showBubble = ref(false);const addToCart = async (id) =&gt; &#123;\ttry &#123;\t\t//...\t\tconst response = await axios.put(\t\t\t//...\t\t);\t\tshowBubble.value = true;\t\tsetTimeout(() =&gt; &#123;\t\t\tshowBubble.value = false;\t\t&#125;, 2000);\t\t\t\tconsole.log(response.data);\t&#125; catch (error) &#123;\t\tconsole.log(error);\t&#125;&#125;;const closeBubble = () =&gt; &#123;\tshowBubble.value = false;&#125;;\n\n查看購物車內容新增 CartPage.vue，使用先前學到的 Vue 技巧，從後端取得購物車資料並顯示於頁面上。\n&lt;template&gt;\t&lt;div\t\tclass=&quot;flex items-center justify-between border-b border-gray-200 py-4 font-bold&quot;\t&gt;\t\t&lt;div class=&quot;flex items-center&quot;&gt;\t\t\t&lt;div class=&quot;w-16 h-16&quot;&gt;&lt;/div&gt;\t\t\t&lt;div class=&quot;flex-1 text-gray-700&quot;&gt;商品&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;div class=&quot;flex items-center space-x-4&quot;&gt;\t\t\t&lt;span class=&quot;w-28 text-gray-700&quot;&gt;單價&lt;/span&gt;\t\t\t&lt;span class=&quot;w-20 text-gray-700&quot;&gt;數量&lt;/span&gt;\t\t\t&lt;span class=&quot;w-16 text-gray-700&quot;&gt;總計&lt;/span&gt;\t\t\t&lt;span class=&quot;w-16 text-gray-700&quot;&gt;操作&lt;/span&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;\t&lt;div\t\tv-for=&quot;item in items&quot;\t\t:key=&quot;item.id&quot;\t\tclass=&quot;flex items-center justify-between border-b border-gray-200 py-4&quot;\t&gt;\t\t&lt;!-- 商品顯示部分 --&gt;\t&lt;/div&gt;\t&lt;div class=&quot;text-right mr-4 text-lg&quot;&gt;\t\t總金額 (&#123;&#123;totalQuantity&#125;&#125; 個商品): $&#123;&#123;totalPrice&#125;&#125;\t&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useAuthStore &#125; from &quot;@/stores/auth&quot;;import axios from &quot;axios&quot;;import &#123; computed, onMounted, ref &#125; from &quot;vue&quot;;const authStore = useAuthStore();const items = ref([]);const getCartItems = async () =&gt; &#123;\ttry &#123;\t\tconst response = await axios.get(&quot;http://localhost:8080/api/cart/&quot;, &#123;\t\t\theaders: &#123;\t\t\t\tAuthorization: `Bearer $&#123;authStore.token&#125;`,\t\t\t&#125;,\t\t&#125;);\t\titems.value = response.data.cartItems;\t\ttotalPrice.value = response.data.totalPrice;\t\ttotalQuantity.value = response.data.totalQuantity;\t\tconsole.log(response.data);\t&#125; catch (error) &#123;\t\tconsole.log(error);\t&#125;&#125;;onMounted(() =&gt; &#123;\tif (authStore.isAuthenticated) &#123;\t\tgetCartItems();\t&#125;&#125;);&lt;/script&gt;\n\n更新 router/index.js，添加購物車頁面的路由。\nroutes: [\t// ...\t&#123;\t\tpath: &#x27;/cart&#x27;,\t\tname: &#x27;cart&#x27;,\t\tcomponent: CartPage\t&#125;];\n\n在首頁點擊商品的「Add To Cart」按鈕，然後點選購物車圖標即可前往購物車頁面，查看已選擇的商品。\n\n修改商品數量可以透過「+」或「-」按鈕來增減商品數量，或直接輸入數量數值。當數量小於等於 0 時，商品會從購物車中移除。\n&lt;div class=&quot;flex items-center space-x-2&quot;&gt;\t&lt;button\t\tclass=&quot;bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded&quot;\t\t@click=&quot;updateQuantity(item.id, item.product.id, item.quantity - 1)&quot;\t&gt;\t\t-\t&lt;/button&gt;\t&lt;input\t\ttype=&quot;text&quot;\t\tv-model=&quot;item.quantity&quot;\t\tclass=&quot;border border-gray-300 p-2 w-16 text-center&quot;\t\t@change=&quot;updateQuantity(item.id, item.product.id, item.quantity)&quot;\t/&gt;\t&lt;button\t\tclass=&quot;bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded&quot;\t\t@click=&quot;updateQuantity(item.id, item.product.id, item.quantity + 1)&quot;\t&gt;\t\t+\t&lt;/button&gt;&lt;/div&gt;\n\n每次修改商品數量後重新計算總金額與商品數量，並更新頁面顯示。\n商品維持顯示順序getCartItems的部分做些修改，避免更改數量後，造成顯示順序的變化。\nconst getCartItems = async () =&gt; &#123;\ttry &#123;\t\t//...\t\titems.value = response.data.cartItems.sort((a, b) =&gt; a.id - b.id);\t\t//...\t&#125; catch (error) &#123;\t\t//...\t&#125;&#125;;\n\n\n結帳在 CartPage.vue 添加「Checkout」按鈕，按下後將導向結帳頁面。\n&lt;div class=&quot;text-right mr-4 text-lg&quot;&gt;\t\t總金額 (&#123;&#123; totalQuantity &#125;&#125; 個商品): $&#123;&#123; totalPrice &#125;&#125;\t\t&lt;br /&gt;\t\t&lt;button\t\t\tclass=&quot;bg-orange-500 hover:bg-orange-600 text-white px-2 py-1 rounded&quot;\t\t\t@click=&quot;checkoutHandler()&quot;\t\t&gt;\t\t\tCheckout\t\t&lt;/button&gt;&lt;/div&gt;\n\n建立支付 Session，並轉移到 Stripe 支付頁面。\nconst checkoutHandler = async () =&gt; &#123;\t\tconst response = await axios.get(\t\t\t\t&quot;http://localhost:8080/api/order/create_session&quot;,\t\t\t\t&#123;\t\t\t\t\theaders: &#123;\t\t\t\t\t\tAuthorization: `Bearer $&#123;authStore.token&#125;`,\t\t\t\t\t&#125;,\t\t\t\t&#125;\t\t\t);\twindow.location.href = &quot;&quot; + response.data.url;&#125;;\n\n建立CheckoutSuccess.vue，也就是支付成功後來到的頁面。\n&lt;template&gt;\t&lt;div class=&quot;flex items-center justify-center min-h-screen bg-green-100&quot;&gt;\t\t&lt;div class=&quot;bg-white p-6 rounded-lg shadow-lg text-center&quot;&gt;\t\t\t&lt;h2 class=&quot;text-2xl font-bold mb-2&quot;&gt;Payment Successful&lt;/h2&gt;\t\t\t&lt;p class=&quot;text-gray-700&quot;&gt;Thank you for your purchase!&lt;/p&gt;\t\t\t&lt;button\t\t\t\tclass=&quot;mt-4 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600&quot;                @click=&quot;router.push(&#x27;/&#x27;)&quot;\t\t\t&gt;\t\t\t\tBack To Home\t\t\t&lt;/button&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; useRouter &#125; from &quot;vue-router&quot;;const router = useRouter();&lt;/script&gt;\n\n修改router&#x2F;index.js， 添加相關路由。\n,    &#123;      path: &#x27;/checkout/success&#x27;,      name: &#x27;checkout-success&#x27;,      component: CheckoutSuccess    &#125;\n\n\n顯示訂單歷史更新導航列在 MainNavbar.vue 中，新增「Order」選項。\nconst navigation = [\t&#123; name: &quot;Home&quot;, href: &quot;/&quot;, current: false &#125;,\t&#123; name: &quot;Add Product&quot;, href: &quot;/add&quot;, current: false &#125;,\t&#123; name: &quot;Order&quot;, href: &quot;/order&quot;, current: false &#125;,];\n\n新增路由在 router/index.js 中添加 order 路由。\n&#123;  path: &#x27;/order&#x27;,  name: &#x27;order&#x27;,  component: UserOrder&#125;\n\n建立 UserOrder.vue 頁面新增 UserOrder.vue，顯示使用者的 Session ID、總金額及付款狀態，並在等待資料時顯示載入動畫。\n&lt;template&gt;\t&lt;div class=&quot;container mx-auto p-6&quot;&gt;\t\t&lt;h1 class=&quot;text-3xl font-extrabold text-gray-800 mb-8 text-center&quot;&gt;\t\t\tUser Orders\t\t&lt;/h1&gt;\t\t&lt;div v-if=&quot;loading&quot; class=&quot;flex justify-center items-center h-48&quot;&gt;\t\t\t&lt;div class=&quot;w-16 h-16 border-4 border-gray-300 border-t-4 border-t-blue-500 rounded-full animate-spin&quot;&gt;&lt;/div&gt;\t\t&lt;/div&gt;\t\t&lt;div v-else class=&quot;bg-white shadow-lg rounded-lg overflow-hidden&quot;&gt;\t\t\t&lt;table class=&quot;min-w-full leading-normal&quot;&gt;\t\t\t\t&lt;thead&gt;\t\t\t\t\t&lt;tr&gt;\t\t\t\t\t\t&lt;th class=&quot;px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider&quot;&gt;\t\t\t\t\t\t\tSession ID\t\t\t\t\t\t&lt;/th&gt;\t\t\t\t\t\t&lt;th class=&quot;px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider&quot;&gt;\t\t\t\t\t\t\tAmount\t\t\t\t\t\t&lt;/th&gt;\t\t\t\t\t\t&lt;th class=&quot;px-5 py-3 border-b-2 border-gray-200 bg-gray-100 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider&quot;&gt;\t\t\t\t\t\t\tStatus\t\t\t\t\t\t&lt;/th&gt;\t\t\t\t\t&lt;/tr&gt;\t\t\t\t&lt;/thead&gt;\t\t\t\t&lt;tbody&gt;\t\t\t\t\t&lt;tr v-for=&quot;order in orders&quot; :key=&quot;order.id&quot; class=&quot;border-b border-gray-200 bg-white hover:bg-gray-50 transition duration-150&quot;&gt;\t\t\t\t\t\t&lt;td class=&quot;px-5 py-5 text-sm&quot;&gt;\t\t\t\t\t\t\t&lt;p class=&quot;text-gray-900 whitespace-no-wrap&quot;&gt;&#123;&#123; order.sessionId &#125;&#125;&lt;/p&gt;\t\t\t\t\t\t&lt;/td&gt;\t\t\t\t\t\t&lt;td class=&quot;px-5 py-5 text-sm&quot;&gt;\t\t\t\t\t\t\t&lt;p class=&quot;text-gray-900 whitespace-no-wrap&quot;&gt;$TWD &#123;&#123; order.amount &#125;&#125;&lt;/p&gt;\t\t\t\t\t\t&lt;/td&gt;\t\t\t\t\t\t&lt;td class=&quot;px-5 py-5 text-sm&quot;&gt;\t\t\t\t\t\t\t&lt;span :class=&quot;&#123;\t\t\t\t\t\t\t\t&#x27;inline-block px-3 py-1 font-semibold text-green-800 bg-green-200 rounded-full&#x27;: order.status === &#x27;paid&#x27;,\t\t\t\t\t\t\t\t&#x27;inline-block px-3 py-1 font-semibold text-yellow-800 bg-yellow-200 rounded-full&#x27;: order.status === &#x27;unpaid&#x27;\t\t\t\t\t\t\t&#125;&quot;&gt;\t\t\t\t\t\t\t\t&#123;&#123; order.status &#125;&#125;\t\t\t\t\t\t\t&lt;/span&gt;\t\t\t\t\t\t\t&lt;button v-if=&quot;order.status === &#x27;unpaid&#x27;&quot; @click=&quot;goToPaymentSession(order.url)&quot; class=&quot;bg-green-500 hover:bg-green-600 text-white px-4 py-1 rounded&quot;&gt;\t\t\t\t\t\t\t\tClick Here to Pay\t\t\t\t\t\t\t&lt;/button&gt;\t\t\t\t\t\t&lt;/td&gt;\t\t\t\t\t&lt;/tr&gt;\t\t\t\t&lt;/tbody&gt;\t\t\t&lt;/table&gt;\t\t&lt;/div&gt;\t&lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import axios from &quot;axios&quot;;import &#123; useAuthStore &#125; from &quot;@/stores/auth&quot;;import &#123; onMounted, ref &#125; from &quot;vue&quot;;const authStore = useAuthStore();const orders = ref([]);const loading = ref(true);const getOrders = async () =&gt; &#123;\ttry &#123;\t\tconst response = await axios.get(&quot;http://localhost:8080/api/order/find_order&quot;, &#123;\t\t\theaders: &#123; Authorization: `Bearer $&#123;authStore.token&#125;` &#125;,\t\t&#125;);\t\torders.value = response.data;\t&#125; catch (error) &#123;\t\tconsole.log(error);\t&#125; finally &#123;\t\tloading.value = false;\t&#125;&#125;;const goToPaymentSession = (url) =&gt; &#123;\twindow.location.href = url;&#125;;onMounted(() =&gt; &#123;\tgetOrders();&#125;);&lt;/script&gt;\n\n若訂單狀態為未付款 (unpaid)，則顯示「前往付款」的按鈕，點擊後跳轉至付款頁面。\n我們的購物車前端專案完成了！\n\n程式碼在開始之前，請使用以下指令來安裝 npm 套件：\nnpm i\n\n或是：\nbun i\n\n專案下載：檔案下載\n\nSSL 設定在專案的根目錄下新增一個名為 SSL 的資料夾，用來存放 SSL 的私鑰和憑證檔案。\n\n產生私鑰openssl genrsa -out private.key 2048\n\n產生自簽憑證openssl req -new -x509 -key private.key -out certificate.crt -days 365 -config openssl.conf\n\n詳細的 SSL 產生步驟解說可以參考 本系列的第22篇文字 。\n\n修改 Vite 設定以啟用 HTTPS在 vite.config.js 中啟用 HTTPS，並導入私鑰和憑證檔案：\nimport &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import fs from &#x27;fs&#x27;import path from &#x27;path&#x27;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [vue()],  resolve: &#123;    alias: &#123;      &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url))    &#125;  &#125;,  base: &#x27;./&#x27;,  server: &#123;    https: &#123;      key: fs.readFileSync(path.resolve(&#x27;./ssl/private.key&#x27;)),      cert: fs.readFileSync(path.resolve(&#x27;./ssl/certificate.crt&#x27;))    &#125;  &#125;&#125;)\n\n\nSpring Boot 的 CORS 設定若後端使用 Spring Boot，請將 CORS 設定中的 http 改為 https：\nconfig.setAllowedOrigins(Arrays.asList(    &quot;https://localhost:5173&quot;));\n\n如果前端使用 HTTPS，後端是 HTTP，可能會因為 HSTS 觸發 preflight request，需要允許 OPTIONS 請求通過：\nconfig.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;));\n\n\n測試頁面打開瀏覽器並前往 https://localhost:5173/ 。由於我們使用的是自簽憑證，瀏覽器會顯示「此連線不安全」的提示。其實，這個網站是安全的。\n\n點擊 進階。\n\n\n選擇 繼續前往。\n\n\n確認前端可以順利從後端取得資料：\n\n\n\n","categories":["Vue.js"],"tags":["Restful API","Vue.js"]},{"title":"Spring Boot project-oriented programming（31）Vue.js 打造 RESTful API前端：打包並部署到Linux","url":"/2024/11/09/spring-boot-pop-31/","content":"打包 Vue 專案修改 vite.config.js，新增 base: &#39;./&#39;，使專案使用相對路徑而非絕對路徑。\nexport default defineConfig(&#123;  plugins: [    vue(),  ],  resolve: &#123;    alias: &#123;      &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url))    &#125;  &#125;,  base: &#x27;./&#x27;,&#125;)\n\n接著，輸入以下指令打包專案：\nbun run build\n\n在 Linux 部署專案將打包好的 Vue 專案和後端的 JAR 檔案上傳至 Linux VPS中，使用Ubuntu作為範例。\n後端設定安裝 MariaDBsudo apt-get install mariadb-server\n\n設定開機時自動啟動 MariaDB：\nsudo systemctl enable mariadb\n\n進行資料庫的初始設定：\nsudo mysql_secure_installation\n\n\n初次安裝時，密碼為空，直接按 Enter。\nSwitch to unix_socket authentication [Y&#x2F;n]: n\nChange the root password? [Y&#x2F;n]: y\nRemove anonymous users? [Y&#x2F;n]: y\nDisallow root login remotely? [Y&#x2F;n]: y\nRemove test database and access to it? [Y&#x2F;n]: y\nReload privilege tables now? [Y&#x2F;n]: y\n\n設定完成後，登入 MariaDB 並建立 cart_db 資料庫：\nmariadb --user root --passwordCREATE DATABASE cart_db;exit\n\n啟動後端應用執行後端的 JAR 檔案：\njava -jar shopping_cart_project-0.0.1-SNAPSHOT.jar\n\n確保 .env 檔與 JAR 檔放在同一資料夾中。\n前端設定安裝與設定 Nginx安裝 Nginx 來顯示 Vue 專案：\nsudo apt-get install nginx\n\n修改 /etc/nginx/sites-available/default，將預設的 port 80 改為 5173：\nsudo nano /etc/nginx/sites-available/default\n\n找到以下部分：\nserver &#123;    listen 80 default_server;    listen [::]:80 default_server;&#125;\n\n將 80 改為 5173，並儲存離開。\n重新啟動 Nginx 使更改生效，並設定開機自動啟動：\nsudo systemctl restart nginxsudo systemctl enable nginx\n\n將 Vue 專案的 dist 資料夾內的內容（如 assets 資料夾、favicon.ico、index.html）複製到 VPS 的 /usr/share/nginx/html 中。\n確認後端正常運作後，訪問 VPS_IP:5173 即可查看部署成功的前端介面。\n維持後端運作使用 tmux 來讓後端在 SSH 連線中斷後仍持續運作：\ntmuxjava -jar shopping_cart_project-0.0.1-SNAPSHOT.jar\n\n若需要停止後端運作，重新連線並輸入：\ntmux attach -t 0\n\n在此工作階段中按下 Ctrl+C 後輸入 exit 以結束。\n","categories":["Vue.js"],"tags":["Restful API","Vue.js"]},{"title":"ArchLinux初體驗，使用ArchInstall","url":"/2025/04/16/ArchInstall/","content":"Arch Linux 安裝教學我們首先從 ISO 開機，選擇第一個 Arch Linux install medium。會看到一堆 OK 畫面，這代表系統正在 Boot。等到畫面切換，出現 root@archiso，我們就能開始操作了。\n網路測試ping archlinux.org\n\n確認網路連線正常。\n啟動安裝archinstall\n\n接下來就輕鬆多了。\n基本設定\nMirrors and repositories選擇 Select regions，挑選適合的伺服器位置。選完後選 Back。\n\nDisk configuration\n\nPartitioning → Use a best-effort default partition layout\nFilesystem 選擇 ext4分割區設定就會自動完成，然後 Back。\n\n\n確認 Swap 是否啟用。當 RAM 用滿時，系統會使用 Swap，避免記憶體不足造成當機。\n\n\n帳號與密碼\nRoot password：設定 root 密碼。\nUser account：輸入使用者名稱、密碼並確認，然後問你要不要 superuser 權限，選 yes，然後 Confirm and exit。\n\n系統與驅動\nProfile\n\nType 選擇 Desktop\n推薦輕量的桌面環境：xfce4\n\n\nGraphics\n\n選擇顯示卡驅動程式如果是 Nvidia，建議用 Nvidia (proprietary)，問題比較少。\n\n\nAudio\n\n如果要聲音建議用 PipeWire\n不需要聲音可以選 No audio server\n\n\nNetwork configuration\n\n選 Copy ISO network 開頭的選項\n\n\nTimezone\n\n選擇你的時區，選單很長，慢慢找沒關係。\n\n\n\n開始安裝完成以上設定後，按下 Install，然後選 Yes，系統就會自動安裝。\n安裝完成安裝完成後，會問要不要 chroot，我們安裝時設定過了，選 No。\nreboot\n\n重新開機，選擇 Arch Linux，然後登入剛才建立的使用者帳號與密碼，就能進入桌面啦！\n","tags":["Arch"]},{"title":"pacman下載速度慢，如何解決","url":"/2025/04/17/arch-reflector/","content":"pacman 是 Arch Linux 內建的套件管理工具，不過我們剛裝好系統，當用 pacman 安裝一些套件時，下載速度竟然只有 100KB&#x2F;s！這很可能是因為我們的下載節點（mirror）選得不好。\n接下來我來教大家，怎麼換成速度更快的節點。\n首先，我們可以用  \ncat /etc/pacman.d/mirrorlist\n來查看目前的鏡像站清單。結果發現第一順位竟然是 澳洲（au），難怪這麼慢。\n雖然我們可以直接手動改這個檔案，但要打一堆字有點麻煩。我建議大家直接用 reflector 這個工具，指令少、效率高。\n安裝 reflector：sudo pacman -S reflector\n\n我自己是選擇台灣、日本、韓國的節點，然後挑出最新、速度最快的 5 個，直接覆蓋掉原本的 mirrorlist。\n指令如下：sudo reflector --country &#x27;Taiwan&#x27;,&#x27;Japan&#x27;,&#x27;South Korea&#x27; --latest 5 --sort rate --save /etc/pacman.d/mirrorlist\n\n接著更新一下套件資料庫：\nsudo pacman -Syyu\n\n這樣我們的下載速度就回來了\n","tags":["Arch"]}]